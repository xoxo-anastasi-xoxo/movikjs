var MovikJS =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: BaseboneConstraintType3D, BaseboneConstraintType2D, JointType, BoneConnectionPoint, ConstraintCoordinateSystem, FabrikJoint2D, FabrikJoint3D, FabrikBone2D, FabrikBone3D, FabrikChain2D, FabrikChain3D, FabrikStructure2D, FabrikStructure3D, Vec3f, Mat3f, Mat4f, Vec2f, Utils, Colour4f, Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main/BaseboneConstraintType3D */ \"./src/main/BaseboneConstraintType3D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseboneConstraintType3D\", function() { return _main_BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_0__[\"BaseboneConstraintType3D\"]; });\n\n/* harmony import */ var _main_BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main/BaseboneConstraintType2D */ \"./src/main/BaseboneConstraintType2D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseboneConstraintType2D\", function() { return _main_BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_1__[\"BaseboneConstraintType2D\"]; });\n\n/* harmony import */ var _main_JointType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main/JointType */ \"./src/main/JointType.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JointType\", function() { return _main_JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"]; });\n\n/* harmony import */ var _main_BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main/BoneConnectionPoint */ \"./src/main/BoneConnectionPoint.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BoneConnectionPoint\", function() { return _main_BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_3__[\"BoneConnectionPoint\"]; });\n\n/* harmony import */ var _main_ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main/ConstraintCoordinateSystem */ \"./src/main/ConstraintCoordinateSystem.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ConstraintCoordinateSystem\", function() { return _main_ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_4__[\"ConstraintCoordinateSystem\"]; });\n\n/* harmony import */ var _main_FabrikJoint2D__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./main/FabrikJoint2D */ \"./src/main/FabrikJoint2D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikJoint2D\", function() { return _main_FabrikJoint2D__WEBPACK_IMPORTED_MODULE_5__[\"FabrikJoint2D\"]; });\n\n/* harmony import */ var _main_FabrikJoint3D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./main/FabrikJoint3D */ \"./src/main/FabrikJoint3D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikJoint3D\", function() { return _main_FabrikJoint3D__WEBPACK_IMPORTED_MODULE_6__[\"FabrikJoint3D\"]; });\n\n/* harmony import */ var _main_FabrikBone2D__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./main/FabrikBone2D */ \"./src/main/FabrikBone2D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikBone2D\", function() { return _main_FabrikBone2D__WEBPACK_IMPORTED_MODULE_7__[\"FabrikBone2D\"]; });\n\n/* harmony import */ var _main_FabrikBone3D__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./main/FabrikBone3D */ \"./src/main/FabrikBone3D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikBone3D\", function() { return _main_FabrikBone3D__WEBPACK_IMPORTED_MODULE_8__[\"FabrikBone3D\"]; });\n\n/* harmony import */ var _main_FabrikChain2D__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./main/FabrikChain2D */ \"./src/main/FabrikChain2D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikChain2D\", function() { return _main_FabrikChain2D__WEBPACK_IMPORTED_MODULE_9__[\"FabrikChain2D\"]; });\n\n/* harmony import */ var _main_FabrikChain3D__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./main/FabrikChain3D */ \"./src/main/FabrikChain3D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikChain3D\", function() { return _main_FabrikChain3D__WEBPACK_IMPORTED_MODULE_10__[\"FabrikChain3D\"]; });\n\n/* harmony import */ var _main_FabrikStructure2D__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./main/FabrikStructure2D */ \"./src/main/FabrikStructure2D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikStructure2D\", function() { return _main_FabrikStructure2D__WEBPACK_IMPORTED_MODULE_11__[\"FabrikStructure2D\"]; });\n\n/* harmony import */ var _main_FabrikStructure3D__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./main/FabrikStructure3D */ \"./src/main/FabrikStructure3D.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FabrikStructure3D\", function() { return _main_FabrikStructure3D__WEBPACK_IMPORTED_MODULE_12__[\"FabrikStructure3D\"]; });\n\n/* harmony import */ var _utils_Vec3f__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/Vec3f */ \"./src/utils/Vec3f.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vec3f\", function() { return _utils_Vec3f__WEBPACK_IMPORTED_MODULE_13__[\"Vec3f\"]; });\n\n/* harmony import */ var _utils_Mat3f__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/Mat3f */ \"./src/utils/Mat3f.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Mat3f\", function() { return _utils_Mat3f__WEBPACK_IMPORTED_MODULE_14__[\"Mat3f\"]; });\n\n/* harmony import */ var _utils_Mat4f__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/Mat4f */ \"./src/utils/Mat4f.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Mat4f\", function() { return _utils_Mat4f__WEBPACK_IMPORTED_MODULE_15__[\"Mat4f\"]; });\n\n/* harmony import */ var _utils_Vec2f__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/Vec2f */ \"./src/utils/Vec2f.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vec2f\", function() { return _utils_Vec2f__WEBPACK_IMPORTED_MODULE_16__[\"Vec2f\"]; });\n\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/Utils */ \"./src/utils/Utils.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return _utils_Utils__WEBPACK_IMPORTED_MODULE_17__[\"Utils\"]; });\n\n/* harmony import */ var _utils_Colour4f__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./utils/Colour4f */ \"./src/utils/Colour4f.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Colour4f\", function() { return _utils_Colour4f__WEBPACK_IMPORTED_MODULE_18__[\"Colour4f\"]; });\n\n/* harmony import */ var _visualisation_Scene__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./visualisation/Scene */ \"./src/visualisation/Scene.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return _visualisation_Scene__WEBPACK_IMPORTED_MODULE_19__[\"Scene\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://MovikJS/./src/index.ts?");

/***/ }),

/***/ "./src/main/BaseboneConstraintType2D.ts":
/*!**********************************************!*\
  !*** ./src/main/BaseboneConstraintType2D.ts ***!
  \**********************************************/
/*! exports provided: BaseboneConstraintType2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseboneConstraintType2D\", function() { return BaseboneConstraintType2D; });\n/**\n * Типы ограничений первой кости в цепи.\n *\n * Имеет следующие значения:\n * <ul>\n * <li>NONE - Без ограничений.</li>\n * <li>GLOBAL_ABSOLUTE - Ограничена относительно мировых координат.</li>\n * <li>LOCAL_RELATIVE - Ограничена относительно прикреплённой к ней кости.</li>\n * <li>LOCAL_ABSOLUTE - Ограничена относительно прикреплённой к ней кости.</li>\n * </ul>\n */\nvar BaseboneConstraintType2D;\n(function (BaseboneConstraintType2D) {\n    BaseboneConstraintType2D[BaseboneConstraintType2D[\"NONE\"] = 0] = \"NONE\";\n    BaseboneConstraintType2D[BaseboneConstraintType2D[\"GLOBAL_ABSOLUTE\"] = 1] = \"GLOBAL_ABSOLUTE\";\n    BaseboneConstraintType2D[BaseboneConstraintType2D[\"LOCAL_RELATIVE\"] = 2] = \"LOCAL_RELATIVE\";\n    BaseboneConstraintType2D[BaseboneConstraintType2D[\"LOCAL_ABSOLUTE\"] = 3] = \"LOCAL_ABSOLUTE\";\n})(BaseboneConstraintType2D || (BaseboneConstraintType2D = {}));\n\n\n//# sourceURL=webpack://MovikJS/./src/main/BaseboneConstraintType2D.ts?");

/***/ }),

/***/ "./src/main/BaseboneConstraintType3D.ts":
/*!**********************************************!*\
  !*** ./src/main/BaseboneConstraintType3D.ts ***!
  \**********************************************/
/*! exports provided: BaseboneConstraintType3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseboneConstraintType3D\", function() { return BaseboneConstraintType3D; });\n/**\n * Типы ограничений первой кости в цепи.\n *\n * Имеет следующие значения:\n * <ul>\n * <li>NONE - Без ограничений.</li>\n * <li>GLOBAL_ROTOR - Ограничена относительно мировых координат. Имеет шарообразные возможности вращения.</li>\n * <li>LOCAL_ROTOR - Ограничена относительно прикреплённой к ней кости. Имеет шарообразные возможности вращения.</li>\n * <li>GLOBAL_HINGE - Ограничена относительно мировых координат. Имеет шарнирные возможности вращения. </li>\n * <li>LOCAL_HINGE - Ограничена относительно прикреплённой к ней кости. Имеет шарнирные возможности вращения. </li>\n * </ul>\n */\nvar BaseboneConstraintType3D;\n(function (BaseboneConstraintType3D) {\n    BaseboneConstraintType3D[BaseboneConstraintType3D[\"NONE\"] = 0] = \"NONE\";\n    BaseboneConstraintType3D[BaseboneConstraintType3D[\"GLOBAL_ROTOR\"] = 1] = \"GLOBAL_ROTOR\";\n    BaseboneConstraintType3D[BaseboneConstraintType3D[\"LOCAL_ROTOR\"] = 2] = \"LOCAL_ROTOR\";\n    BaseboneConstraintType3D[BaseboneConstraintType3D[\"GLOBAL_HINGE\"] = 3] = \"GLOBAL_HINGE\";\n    BaseboneConstraintType3D[BaseboneConstraintType3D[\"LOCAL_HINGE\"] = 4] = \"LOCAL_HINGE\";\n})(BaseboneConstraintType3D || (BaseboneConstraintType3D = {}));\n\n\n//# sourceURL=webpack://MovikJS/./src/main/BaseboneConstraintType3D.ts?");

/***/ }),

/***/ "./src/main/BoneConnectionPoint.ts":
/*!*****************************************!*\
  !*** ./src/main/BoneConnectionPoint.ts ***!
  \*****************************************/
/*! exports provided: BoneConnectionPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoneConnectionPoint\", function() { return BoneConnectionPoint; });\n/**\n * Типы связи между FabrikBone.\n * В начале или конце кости хозяина располагается данная кость.\n */\nvar BoneConnectionPoint;\n(function (BoneConnectionPoint) {\n    BoneConnectionPoint[BoneConnectionPoint[\"START\"] = 0] = \"START\";\n    BoneConnectionPoint[BoneConnectionPoint[\"END\"] = 1] = \"END\";\n})(BoneConnectionPoint || (BoneConnectionPoint = {}));\n\n\n//# sourceURL=webpack://MovikJS/./src/main/BoneConnectionPoint.ts?");

/***/ }),

/***/ "./src/main/ConstraintCoordinateSystem.ts":
/*!************************************************!*\
  !*** ./src/main/ConstraintCoordinateSystem.ts ***!
  \************************************************/
/*! exports provided: ConstraintCoordinateSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstraintCoordinateSystem\", function() { return ConstraintCoordinateSystem; });\n/**\n * ConstraintCoordinateSystem\tСистема координат, относительно которой рассматривается ограничения.\n * <p>\n * LOCAL (default) - относительно предыдущей кости в цепи.\n * GLOBAL - относитьльно мировой системы координат.\n */\nvar ConstraintCoordinateSystem;\n(function (ConstraintCoordinateSystem) {\n    ConstraintCoordinateSystem[ConstraintCoordinateSystem[\"LOCAL\"] = 0] = \"LOCAL\";\n    ConstraintCoordinateSystem[ConstraintCoordinateSystem[\"GLOBAL\"] = 1] = \"GLOBAL\";\n})(ConstraintCoordinateSystem || (ConstraintCoordinateSystem = {}));\n\n\n//# sourceURL=webpack://MovikJS/./src/main/ConstraintCoordinateSystem.ts?");

/***/ }),

/***/ "./src/main/FabrikBone2D.ts":
/*!**********************************!*\
  !*** ./src/main/FabrikBone2D.ts ***!
  \**********************************/
/*! exports provided: FabrikBone2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikBone2D\", function() { return FabrikBone2D; });\n/* harmony import */ var _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Vec2f */ \"./src/utils/Vec2f.ts\");\n/* harmony import */ var _FabrikJoint2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FabrikJoint2D */ \"./src/main/FabrikJoint2D.ts\");\n/* harmony import */ var _utils_Colour4f__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Colour4f */ \"./src/utils/Colour4f.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n\n\n\n\n/**\n * Кость.\n * <p>\n * FabrikBone2D состоит из начальной и конечной позиции и FabrikJoint2D, который ограничивает возможность поворота\n * относительно предыдущей кости в цепи или мировой системы координат.\n */\nvar FabrikBone2D = /** @class */ (function () {\n    // ---------- Constructors ----------\n    /**\n     * Конструктор.\n     * <p>\n     * Принимает несколько возможных комбинаций параметров:\n     * <p>\n     * Конструктор без параметров. Все поля класса принимают значения по умолчанию.\n     * <p>\n     * Если третий параметр конструктора задан как null или undefiened, но при этом первые 2 параметра присутствуют,\n     * то конструктор будет воспринимать первые 2 параметра как начальную и конечную позиции данной кости.\n     * Параметры с четвертого по седьмой опциональны.\n     *\n     * @param\tstartLocation\t            Начальная позиция кости в мировой системе координат.\n     * @param\tendLocationOrDirection\t\tКонечная позиция кости в мировой системе координат.\n     * @param\tlength\t\t                null или undefined.\n     * @param\tcwConstraintDegs\t\t    Угол-ограничение по часовой стрелке.\n     * @param\tacwConstraintDegs\t\t    Угол-ограничение против часовой стрелки.\n     * @param\tcolour\t\t                Цвет кости.\n     * @param\tname\t\t                Название кости.\n     * <p>\n     * Если третий параметр конструктора - это число, но при этом первые 2 параметра присутствуют,\n     * то конструктор будет воспринимать первые 2 параметра как начальную позицию данной кости и её направление.\n     * Параметры с четвертого по седьмой опциональны.\n     *\n     * @param\tstartLocation\t            Начальная позиция кости в мировой системе координат.\n     * @param\tendLocationOrDirection\t\tКонечная позиция кости в мировой системе координат.\n     * @param\tlength\t\t                null или undefined.\n     * @param\tcwConstraintDegs\t\t    Угол-ограничение по часовой стрелке.\n     * @param\tacwConstraintDegs\t\t    Угол-ограничение против часовой стрелки.\n     * @param\tcolour\t\t                Цвет кости.\n     * @param\tname\t\t                Название кости.\n     */\n    function FabrikBone2D(startLocation, endLocationOrDirection, length, cwConstraintDegs, acwConstraintDegs, colour, name) {\n        var _this = this;\n        /**\n         * _joint\tСустав прикреплённый к FabrikBone2D.\n         * <p>\n         * Каждая кость содержит один сустав, который крепит данную кость к предыдущей.\n         * <p>\n         * По умолчанию сустав ничем не ограничен. Он может вращаться во всех возможных направлениях.\n         * Изменить параметры сустава можно через конструктор кости или с помощью методов\n         * {@link #setClockwiseConstraintDegs(float)} и {@link #setAnticlockwiseConstraintDegs(float)}.\n         */\n        this._joint = new _FabrikJoint2D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint2D\"]();\n        /**\n         * _startLocation\tНачальная позиция кости.\n         * <p>\n         * Начальная позиция может быть задана через конструктоp или с помощью методов 'addBone'\n         * или 'addConsecutiveBone' из класса {@link FabrikChain2D}.\n         */\n        this._startLocation = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"]();\n        /**\n         * _endLocation\tКонечная позиция кости.\n         * <p>\n         * Конечная позиция может быть задана через конструктоp или с помощью метода 'addBone'\n         * из класса {@link FabrikChain2D}.\n         */\n        this._endLocation = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"]();\n        /**\n         * _name\tНазвание кости.\n         * <p>\n         * Необязательное поле,облегчающее идентификацию кости в цепи.\n         */\n        this._name = '';\n        this._globalConstraintUV = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"](1.0, 0.0);\n        /**\n         * Цвет кости.\n         * <p>\n         * По умолчанию кость белая непрозрачная.\n         */\n        this._colour = new _utils_Colour4f__WEBPACK_IMPORTED_MODULE_2__[\"Colour4f\"]();\n        this.getGlobalConstraintUV = function () { return _this._globalConstraintUV; };\n        /**\n         * Возвращает длину кости.\n         *\n         * @return\n         */\n        this.getLength = function () { return _this._length; };\n        /**\n         * Возвращает цвет кости.\n         *\n         * @return  Цвет кости.\n         */\n        this.getColour = function () { return _this._colour; };\n        /**\n         * Возвращает начальную позицию кости.\n         *\n         * @return Начальная позиция кости.\n         */\n        this.getStartLocation = function () { return _this._startLocation; };\n        /**\n         * Возвращает начальную позицию кости в виде числового массива.\n         *\n         * @return  Начальная позиция кости.\n         */\n        this.getStartLocationAsArray = function () { return [_this._startLocation.x, _this._startLocation.y]; };\n        /**\n         * Возвращает конечную позицию кости.\n         *\n         * @return Конечная позиция кости.\n         */\n        this.getEndLocation = function () { return _this._endLocation; };\n        /**\n         * Возвращает конечную позицию кости в виде числового массива.\n         *\n         * @return  Конечная позиция кости.\n         */\n        this.getEndLocationAsArray = function () { return [_this._endLocation.x, _this._endLocation.y]; };\n        /**\n         * Возвращает сустав для кости.\n         *\n         * @return  Сустав.\n         */\n        this.getJoint = function () { return _this._joint; };\n        /**\n         * Возвращает угол-ограничение по часовой стрелке для сустава кости.\n         *\n         * @return  Угол-ограничение по часовой стрелке в градусах.\n         */\n        this.getClockwiseConstraintDegs = function () { return _this._joint.getClockwiseConstraintDegs(); };\n        /**\n         * Возвращает направление кости.\n         * <p>\n         * Если необходимо получить направление обратное направлению кости - воспользуйтесь методом negated вектора.\n         *\n         * @return  Единичный вектор направления данной кости.\n         * @see\t\tVec2f#negated()\n         */\n        this.getDirectionUV = function () { return _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"].getDirectionUV(_this._startLocation, _this._endLocation); };\n        /**\n         * Возвращает имя кости.\n         *\n         * @return\tИмя.\n         */\n        this.getName = function () { return _this._name; };\n        /**\n         * Возвращает тип сустава.\n         *\n         * @return\tТип сустава.\n         */\n        this.getJointConstraintCoordinateSystem = function () { return _this._joint.getConstraintCoordinateSystem(); };\n        switch (arguments.length) {\n            case 0:\n                break;\n            case 1:\n                throw new Error('FabrikBone2D constructor can not have 1 param.');\n            default:\n                if (!startLocation || !endLocationOrDirection) {\n                    throw new Error('Invalid FabrikBone2D constructor params.');\n                }\n                if (length === null || length === undefined) {\n                    // Представляем первые 2 вектора как начальную и конечную позиции кости.\n                    this._startLocation.set(startLocation);\n                    this._endLocation.set(endLocationOrDirection);\n                    this._updateLength();\n                }\n                else {\n                    // Представляем первые 2 вектора как начальную позицию и направление кости.\n                    _utils_Utils__WEBPACK_IMPORTED_MODULE_3__[\"Utils\"].validateDirectionUV(endLocationOrDirection);\n                    this._startLocation.set(startLocation);\n                    this._endLocation.set(this._startLocation.plus(_utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"].normalised(endLocationOrDirection).times(length)));\n                    this._updateLength();\n                }\n                if (typeof cwConstraintDegs === 'number')\n                    this.setClockwiseConstraintDegs(cwConstraintDegs);\n                if (typeof acwConstraintDegs === 'number')\n                    this.setAnticlockwiseConstraintDegs(acwConstraintDegs);\n                if (colour instanceof _utils_Colour4f__WEBPACK_IMPORTED_MODULE_2__[\"Colour4f\"])\n                    this._colour.set(colour.toArray());\n                if (typeof name === 'string')\n                    this._name = name;\n        }\n    }\n    // ---------- Methods ----------\n    /**\n     * Задаёт всем полям данной кости такие жа значения как у кости источника.\n     * <p>\n     * Копирование свойств неглубокое.\n     * После применнеия метода данная кость и кость источник будут содержать общие элементы.\n     *\n     * @param\tsource\tКость источник.\n     */\n    FabrikBone2D.prototype.set = function (source) {\n        this._startLocation.set(source._startLocation);\n        this._endLocation.set(source._endLocation);\n        this._joint.set(source._joint);\n        this._colour.set(source._colour.toArray());\n        this._name = source._name;\n        this._length = source._length;\n        this._globalConstraintUV = source._globalConstraintUV;\n    };\n    /**\n     * Задаёт цвет кости.\n     *\n     * @param\tcolour\tЦвет кости.\n     */\n    FabrikBone2D.prototype.setColour = function (colour) { this._colour.set(colour.toArray()); };\n    /**\n     * Задаёт начальную позицию кости.\n     *\n     * @param location Начальная позиция кости.\n     */\n    FabrikBone2D.prototype.setStartLocation = function (location) {\n        this._startLocation.set(location);\n    };\n    /**\n     * Задаёт конечную позицию кости.\n     *\n     * @param location Конечная позиция кости.\n     */\n    FabrikBone2D.prototype.setEndLocation = function (location) {\n        this._endLocation.set(location);\n    };\n    /**\n     * Задаёт сустав для кости.\n     *\n     * @param  joint  Сустав.\n     */\n    FabrikBone2D.prototype.setJoint = function (joint) { this._joint.set(joint); };\n    /**\n     * Задаёт угол-ограничение по часовой стрелке для сустава кости.\n     * <p>\n     * При передаче угла вне допустимого диапазона, угол приравневается к одному из граничных значений.\n     *\n     * @param  angleDegs  Угол-ограничение в градусах.\n     */\n    FabrikBone2D.prototype.setClockwiseConstraintDegs = function (angleDegs) { this._joint.setClockwiseConstraintDegs(angleDegs); };\n    /**\n     * Задаёт угол-ограничение против часовой стрелки для сустава кости.\n     * <p>\n     * При передаче угла вне допустимого диапазона, угол приравневается к одному из граничных значений.\n     *\n     * @param  angleDegs  Угол-ограничение в градусах.\n     */\n    FabrikBone2D.prototype.setAnticlockwiseConstraintDegs = function (angleDegs) { this._joint.setAnticlockwiseConstraintDegs(angleDegs); };\n    /**\n     * Возвращает угол-ограничение против часовой стрелки для сустава кости.\n     *\n     * @return  Угол-ограничение против часовой стрелки в градусах.\n     */\n    FabrikBone2D.prototype.getAnticlockwiseConstraintDegs = function () { return this._joint.getAnticlockwiseConstraintDegs(); };\n    /**\n     * Задаёт значение имени кости.\n     *\n     * @param\tname\tИмя.\n     */\n    FabrikBone2D.prototype.setName = function (name) { this._name = name; };\n    /**\n     * Задаёт тип сустава.\n     *\n     * @param\tcoordSystem\t\tТип сустава.\n     */\n    FabrikBone2D.prototype.setJointConstraintCoordinateSystem = function (coordSystem) {\n        this._joint.setConstraintCoordinateSystem(coordSystem);\n    };\n    /**\n     * Пересчитывает длину кости, опираясь на внутренние поля начальной и конечной позиции.\n     */\n    FabrikBone2D.prototype._updateLength = function () {\n        var length = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"].distanceBetween(this._startLocation, this._endLocation);\n        if (length >= 0.0) {\n            this._length = length;\n        }\n        else {\n            throw new Error('Bone getLength must be a positive value.');\n        }\n    };\n    return FabrikBone2D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikBone2D.ts?");

/***/ }),

/***/ "./src/main/FabrikBone3D.ts":
/*!**********************************!*\
  !*** ./src/main/FabrikBone3D.ts ***!
  \**********************************/
/*! exports provided: FabrikBone3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikBone3D\", function() { return FabrikBone3D; });\n/* harmony import */ var _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoneConnectionPoint */ \"./src/main/BoneConnectionPoint.ts\");\n/* harmony import */ var _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FabrikJoint3D */ \"./src/main/FabrikJoint3D.ts\");\n/* harmony import */ var _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Vec3f */ \"./src/utils/Vec3f.ts\");\n/* harmony import */ var _utils_Colour4f__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Colour4f */ \"./src/utils/Colour4f.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n\n\n\n\n\n/**\n * Кость.\n * <p>\n * FabrikBone3D состоит из начальной и конечной позиции и FabrikJoint3D, который ограничивает возможность поворота.\n */\nvar FabrikBone3D = /** @class */ (function () {\n    // ---------- Constructors ----------\n    /**\n     * Конструктор.\n     * <p>\n     * Принимает несколько возможных комбинаций параметров:\n     * <p>\n     * Конструктор без параметров. Все поля класса принимают значения по умолчанию.\n     * <p>\n     * Если третий параметр конструктора задан как null или undefiened, но при этом первые 2 параметра присутствуют,\n     * то конструктор будет воспринимать первые 2 параметра как начальную и конечную позиции данной кости.\n     * Параметры с четвертого по седьмой опциональны.\n     *\n     * @param\tstartLocation\t            Начальная позиция кости в мировой системе координат.\n     * @param\tendLocationOrDirection\t\tКонечная позиция кости в мировой системе координат.\n     * @param\tlength\t\t                null или undefined.\n     * @param\tcolour\t\t                Цвет кости.\n     * @param\tname\t\t                Название кости.\n     * <p>\n     * Если третий параметр конструктора - это число, но при этом первые 2 параметра присутствуют,\n     * то конструктор будет воспринимать первые 2 параметра как начальную позицию данной кости и её направление.\n     * Параметры с четвертого по седьмой опциональны.\n     *\n     * @param\tstartLocation\t            Начальная позиция кости в мировой системе координат.\n     * @param\tendLocationOrDirection\t\tКонечная позиция кости в мировой системе координат.\n     * @param\tlength\t\t                null или undefined.\n     * @param\tcolour\t\t                Цвет кости.\n     * @param\tname\t\t                Название кости.\n     */\n    function FabrikBone3D(startLocation, endLocationOrDirection, length, colour, name) {\n        var _this = this;\n        /**\n         * Если данная кость присоединена к кости из другой цепи, к какому концу другой цепи она должна присоединяться?\n         * <p>\n         * По умолчанию присоединяется к концу данной кости.\n         * <p>\n         * Это поле может быть изменено с помощью метода {#link #setBoneConnectionPoint(BoneConnectionPoint)}, или при соединении кости\n         * с другой цепью с помощью метода {@link FabrikStructure3D#connectChain(FabrikChain3D, number, number, BoneConnectionPoint)}.\n         */\n        this._boneConnectionPoint = _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_0__[\"BoneConnectionPoint\"].END;\n        /**\n         * _joint\tСустав для данной кости.\n         * <p>\n         * У каждой кости есть один сустав, располагающийся в начальной позиции кости.\n         * Он определяет как кость может быть повернута относительно предыдущей кости в цепи.\n         * <p>\n         * По умолчанию сустав не имеет ограничений, но они могут быть заданы с помощью методов\n         * {@link #setClockwiseConstraintDegs(number)} и {@link #setAnticlockwiseConstraintDegs(number)}.\n         */\n        this._joint = new _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"]();\n        /**\n         * _startLocation\tНачальная позиция кости.\n         * <p>\n         * Начальная позиция должна задаваться только через конструктор или\n         * с помощью метода 'addBone' класса {@link FabrikChain3D}.\n         */\n        this._startLocation = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"]();\n        /**\n         * _endLocation\tКонечная позиция кости.\n         * <p>\n         * Конечная позиция должна задаваться только через конструктор\n         * или через метод 'addBone' класса {@link FabrikChain3D}.\n         */\n        this._endLocation = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"]();\n        /**\n         * _name\tИмя кости.\n         * <p>\n         * Не обязательно использовать это свойство.\n         * Иногда его использование облегчает идентификацию кости в цепи.\n         *\n         * @see #setName(string)\n         * @see #FabrikBone3D(Vec3f, Vec3f, string)\n         * @see #FabrikBone3D(Vec3f, Vec3f, number, string)\n         */\n        this._name = '';\n        /**\n         * Длина кости.\n         */\n        this._length = 0;\n        /**\n         * Цвет для визуализации кости.\n         *\n         * @default Белый непрозрачный - [1, 1, 1, 1].\n         */\n        this._colour = new _utils_Colour4f__WEBPACK_IMPORTED_MODULE_3__[\"Colour4f\"]();\n        /**\n         * Возвращает длину кости.\n         *\n         * @return\n         */\n        this.getLength = function () { return _this._length; };\n        /**\n         * Возвращает длину кости.\n         *\n         * @return\n         */\n        this.getLifeLength = function () { return _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].distanceBetween(_this._startLocation, _this._endLocation); };\n        /**\n         * Возвращает точку соединения с данной костью.\n         *\n         * @return\n         */\n        this.getBoneConnectionPoint = function () { return _this._boneConnectionPoint; };\n        /**\n         * Возвращает цвет кости\n         *\n         * @return\n         */\n        this.getColour = function () { return _this._colour; };\n        /**\n         * Возвращает начальную позицию кости.\n         *\n         * @return Начальная позиция кости.\n         */\n        this.getStartLocation = function () { return _this._startLocation; };\n        /**\n         * Возвращает начальную позицию кости в виде числового массива.\n         *\n         * @return  Начальная позиция кости.\n         */\n        this.getStartLocationAsArray = function () { return [_this._startLocation.x, _this._startLocation.y, _this._startLocation.z]; };\n        /**\n         * Возвращает конечную позицию кости.\n         *\n         * @return Конечная позиция кости.\n         */\n        this.getEndLocation = function () { return _this._endLocation; };\n        /**\n         * Возвращает конечную позицию кости в виде числового массива.\n         *\n         * @return  Конечная позиция кости.\n         */\n        this.getEndLocationAsArray = function () { return [_this._endLocation.x, _this._endLocation.y, _this._endLocation.z]; };\n        /**\n         * Возвращает сустав для кости.\n         *\n         * @return  Сустав.\n         */\n        this.getJoint = function () { return _this._joint; };\n        /**\n         * Возвращает тип сустава.\n         *\n         * @return\n         */\n        this.getJointType = function () { return _this._joint.getJointType(); };\n        /**\n         * Возвращает имя кости.\n         *\n         * @return String\n         */\n        this.getName = function () { return _this._name; };\n        switch (arguments.length) {\n            case 0:\n                break;\n            case 1:\n                throw new Error('FabrikBone2D constructor can not have 1 param.');\n            default:\n                if (!startLocation || !endLocationOrDirection) {\n                    throw new Error('Invalid FabrikBone2D constructor params.');\n                }\n                if (length === null || length === undefined) {\n                    // Представляем первые 2 вектора как начальную и конечную позиции кости.\n                    this._startLocation.set(startLocation);\n                    this._endLocation.set(endLocationOrDirection);\n                    this._updateLength();\n                }\n                else {\n                    // Представляем первые 2 вектора как начальную позицию и направление кости.\n                    _utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"Utils\"].validateDirectionUV(endLocationOrDirection);\n                    this._startLocation.set(startLocation);\n                    this._endLocation.set(this._startLocation.plus(endLocationOrDirection.normalised().times(length)));\n                    this._updateLength();\n                }\n                if (colour instanceof _utils_Colour4f__WEBPACK_IMPORTED_MODULE_3__[\"Colour4f\"])\n                    this._colour.set(colour.toArray());\n                if (typeof name === 'string')\n                    this._name = name;\n        }\n    }\n    // ---------- Methods ----------\n    /**\n     * Задаёт всем полям данной кости такие жа значения как у кости источника.\n     * <p>\n     * Копирование свойств неглубокое.\n     * После применнеия метода данная кость и кость источник будут содержать общие элементы.\n     *\n     * @param\tsource\tКость источник.\n     */\n    FabrikBone3D.prototype.set = function (source) {\n        this._startLocation.set(source._startLocation);\n        this._endLocation.set(source._endLocation);\n        this._joint.set(source._joint);\n        this._colour.set(source._colour.toArray());\n        this._name = source._name;\n        this._length = source._length;\n        this._boneConnectionPoint = source._boneConnectionPoint;\n    };\n    /**\n     * Задаёт точку соединения.\n     * <p>\n     * Эта точка соединения контролирует куда присоединяется кость из другой цепи при соединении с нашей костью.\n     * <p>\n     * Значение по умолчанию BoneConnectionPoint3D.END.\n     *\n     * @param\tbcp\t    Точка соединения (BoneConnectionPoint3.START или BoneConnectionPoint.END).\n     *\n     */\n    FabrikBone3D.prototype.setBoneConnectionPoint = function (bcp) { this._boneConnectionPoint = bcp; };\n    /**\n     * Задаёт цвет кости.\n     *\n     * @param\tcolour\tБудущий цвет кости для отрисовки.\n     */\n    FabrikBone3D.prototype.setColour = function (colour) { this._colour.set(colour.toArray()); };\n    /**\n     * Задаёт сустав для кости.\n     *\n     * @param\tjoint\tСустав.\n     */\n    FabrikBone3D.prototype.setJoint = function (joint) { this._joint.set(joint); };\n    /**\n     * Задаёт угол ограничение по часовой стрелке для шарнирного сустава.\n     * <p>\n     * Вызывает ошибки, если угол выходит за границы допустимых значений и\n     * если тип сустава не шарнирный.\n     *\n     * @param    angleDegs    Угол ограничение по часовой стрелке в градусах.\n     */\n    FabrikBone3D.prototype.setHingeJointClockwiseConstraintDegs = function (angleDegs) { this._joint.setHingeJointClockwiseConstraintDegs(angleDegs); };\n    /**\n     * Возвращает угол-ограничение по часовой стрелке для шарнирного сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шарнирный.\n     *\n     * @return Угол-ограничение по часовой стрелке в градусах.\n     */\n    FabrikBone3D.prototype.getHingeJointClockwiseConstraintDegs = function () { return this._joint.getHingeClockwiseConstraintDegs(); };\n    /**\n     * Задаёт угол ограничение против часовой стрелки для шарнирного сустава.\n     * <p>\n     * Вызывает ошибки, если угол выходит за границы допустимых значений и\n     * если тип сустава не шарнирный.\n     *\n     * @param    angleDegs    Угол ограничение против часовой стрелки в градусах.\n     */\n    FabrikBone3D.prototype.setHingeJointAnticlockwiseConstraintDegs = function (angleDegs) { this._joint.setHingeJointAnticlockwiseConstraintDegs(angleDegs); };\n    /**\n     * Возвращает угол-ограничение против часовой стрелки для шарнирного сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шарнирный.\n     *\n     * @return Угол-ограничение против часовой стрелки в градусах.\n     */\n    FabrikBone3D.prototype.getHingeJointAnticlockwiseConstraintDegs = function () { return this._joint.getHingeAnticlockwiseConstraintDegs(); };\n    /**\n     * Задаёт угол-ограничение для шарового сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шаровой или\n     * угол выходит за границы допустимых значений.\n     *\n     * @param\tangleDegs\tУгол-ограничение в градусах.\n     */\n    FabrikBone3D.prototype.setBallJointConstraintDegs = function (angleDegs) {\n        this._joint.setBallJointConstraintDegs(angleDegs);\n    };\n    /**\n     * Возвращает угол ограничение шарового сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шаровой\n     *\n     * @return\tУгол-ограничение в градусах.\n     */\n    FabrikBone3D.prototype.getBallJointConstraintDegs = function () { return this._joint.getBallJointConstraintDegs(); };\n    /**\n     * Возвращает направление кости.\n     * <p>\n     * Если необходимо получить направление обратное направлению кости - воспользуйтесь методом negated вектора.\n     *\n     * @return  Единичный вектор направления данной кости.\n     * @see\t\tVec3f#negated()\n     */\n    FabrikBone3D.prototype.getDirectionUV = function () {\n        return _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].getDirectionUV(this._startLocation, this._endLocation);\n    };\n    /**\n     * Возвращает глобальный поворот кости относительно глобальной оси X.\n     * Возвращаемое значение находится в диапазоне -179.9..180.0 степени.\n     *\n     * @return\tОтклонение вектора в градусах.\n     **/\n    FabrikBone3D.prototype.getGlobalPitchDegs = function () {\n        return _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].getDirectionUV(this._startLocation, this._endLocation).getGlobalPitchDegs();\n    };\n    /**\n     * Возвращает глобальный поворот кости относительно глобальной оси Y.\n     * Возвращаемое значение находится в диапазоне -179.9..180.0 степени.\n     *\n     * @return\tОтклонение вектора в градусах.\n     **/\n    FabrikBone3D.prototype.getGlobalYawDegs = function () {\n        return _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].getDirectionUV(this._startLocation, this._endLocation).getGlobalYawDegs();\n    };\n    /**\n     * Задаёт имя кости.\n     *\n     * @param\tname\tThe name to set.\n     */\n    FabrikBone3D.prototype.setName = function (name) { this._name = name; };\n    /**\n     * Задаёт начальную позицию кости.\n     *\n     * @param location Начальная позиция кости.\n     */\n    FabrikBone3D.prototype.setStartLocation = function (location) {\n        this._startLocation.set(location);\n    };\n    /**\n     * Задаёт конечную позицию кости.\n     *\n     * @param location Конечная позиция кости.\n     */\n    FabrikBone3D.prototype.setEndLocation = function (location) {\n        this._endLocation.set(location);\n    };\n    /**\n     * Пересчитывает длину кости, опираясь на внутренние поля начальной и конечной позиции.\n     */\n    FabrikBone3D.prototype._updateLength = function () {\n        var length = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].distanceBetween(this._startLocation, this._endLocation);\n        if (length >= 0.0) {\n            this._length = length;\n        }\n        else {\n            throw new Error('Bone getLength must be a positive value.');\n        }\n    };\n    return FabrikBone3D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikBone3D.ts?");

/***/ }),

/***/ "./src/main/FabrikChain2D.ts":
/*!***********************************!*\
  !*** ./src/main/FabrikChain2D.ts ***!
  \***********************************/
/*! exports provided: FabrikChain2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikChain2D\", function() { return FabrikChain2D; });\n/* harmony import */ var _FabrikBone2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FabrikBone2D */ \"./src/main/FabrikBone2D.ts\");\n/* harmony import */ var _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Vec2f */ \"./src/utils/Vec2f.ts\");\n/* harmony import */ var _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BoneConnectionPoint */ \"./src/main/BoneConnectionPoint.ts\");\n/* harmony import */ var _utils_Colour4f__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Colour4f */ \"./src/utils/Colour4f.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n/* harmony import */ var _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConstraintCoordinateSystem */ \"./src/main/ConstraintCoordinateSystem.ts\");\n/* harmony import */ var _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BaseboneConstraintType2D */ \"./src/main/BaseboneConstraintType2D.ts\");\n\n\n\n\n\n\n\n/**\n * 2D цепь костей, решающая задачу инверсной кинематики с помощью алгоритма FABRIK.\n */\nvar FabrikChain2D = /** @class */ (function () {\n    // ---------- Constructors ----------\n    /**\n     * Конструктор.\n     *\n     * Принимает три вариации параметров:\n     *\n     * Без параметров. Всем полям проставляются значения по умолчанию.\n     *\n     * Один параметр-строка.\n     *\n     * @param\tsource\tИмя данной цепи.\n     *\n     * Конструктор копирования.\n     *\n     * @param\tsource\tЦепь для копирования.\n     */\n    function FabrikChain2D(source) {\n        // ---------- Private Properties ----------\n        /**\n         * Массив костей.\n         */\n        this._chain = [];\n        /**\n         * Название цепи.\n         * <p>\n         * Необязательное к использованию поле, помогающее идентифицировать цепь.\n         */\n        this._name = '';\n        /**\n         * Порог, достигнув которого мы считаем задачу инверсной кинематики решенной.\n         * <p>\n         * При решении задачи ИК, когда расстояние между текущим положением и желаемым положением становится меньше или равно\n         * значению порога, мы прерываем дальнейшие итерации и считаем задачу решенной.\n         * <p>\n         * Значение по умолчанию 1.\n         * <p>\n         * Минимально допустимое значение - 0, но стоит помнить о погрешности вычисления и не задавать порог равным нулю, так\n         * как это может привести к бесконечным бесполезным попыткам.\n         * <p>\n         * Хотя данное поле и самый важный критерий останова для ИК-алгоритма, оно работает в комбинации с\n         * {@link #_maxIterationAttempts} и {@link _minIterationChange}. Эти вспомогательные свойства помогают пережить ситуации,\n         * когда длины цепи не хватает для достижения цели или когда суставы цепи сильно ограничены.\n         */\n        this._solveDistanceThreshold = 1.0;\n        /**\n         * Максимальное количество итераций алгоритма, применяемых при решении задачи ИК.\n         *\n         * @default 20\n         */\n        this._maxIterationAttempts = 15;\n        this._minIterationChange = 0.01;\n        this._chainLength = 0;\n        this._baseLocation = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"]();\n        this._fixedBaseMode = true;\n        this._baseboneConstraintType = _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_6__[\"BaseboneConstraintType2D\"].NONE;\n        this._boneConnectionPoint = _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_2__[\"BoneConnectionPoint\"].END;\n        this._baseboneConstraintUV = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"]();\n        this._baseboneRelativeConstraintUV = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"]();\n        this._lastTargetLocation = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"](Number.MAX_VALUE, Number.MAX_VALUE);\n        this._lastBaseLocation = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"](Number.MAX_VALUE, Number.MAX_VALUE);\n        this._embeddedTarget = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"]();\n        this._useEmbeddedTarget = false;\n        this._currentSolveDistance = Number.MAX_VALUE;\n        this._connectedChainNumber = -1;\n        this._connectedBoneNumber = -1;\n        if (!source) {\n            return;\n        }\n        if (typeof source === 'string') {\n            this._name = source;\n        }\n        else {\n            this._chain = source.cloneChainVector();\n            this._baseLocation.set(source._baseLocation);\n            this._lastTargetLocation.set(source._lastTargetLocation);\n            this._lastBaseLocation.set(source._lastBaseLocation);\n            this._baseboneConstraintUV.set(source._baseboneConstraintUV);\n            this._baseboneRelativeConstraintUV.set(source._baseboneRelativeConstraintUV);\n            this._embeddedTarget.set(source._embeddedTarget);\n            this._chainLength = source._chainLength;\n            this._currentSolveDistance = source._currentSolveDistance;\n            this._connectedChainNumber = source._connectedChainNumber;\n            this._connectedBoneNumber = source._connectedBoneNumber;\n            this._baseboneConstraintType = source._baseboneConstraintType;\n            this._boneConnectionPoint = source._boneConnectionPoint;\n            this._name = source._name;\n            this._useEmbeddedTarget = source._useEmbeddedTarget;\n        }\n    }\n    // ---------- Public Methods ------------\n    FabrikChain2D.prototype.addBone = function (bone) {\n        this._chain.push(bone);\n        if (this._chain.length === 1) {\n            this._baseLocation.set(bone.getStartLocation());\n            this._baseboneConstraintUV = bone.getDirectionUV();\n        }\n        this.updateChainLength();\n    };\n    FabrikChain2D.prototype.addConsecutiveConstrainedBone = function (directionUV, length, clockwiseDegs, anticlockwiseDegs, colour) {\n        if (colour === void 0) { colour = new _utils_Colour4f__WEBPACK_IMPORTED_MODULE_3__[\"Colour4f\"](); }\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"Utils\"].validateDirectionUV(directionUV);\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"Utils\"].validateLength(length);\n        if (this._chain.length !== 0) {\n            var prevBoneEnd = this._chain[this._chain.length - 1].getEndLocation();\n            var bone = new _FabrikBone2D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikBone2D\"](prevBoneEnd, _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].normalised(directionUV), length, clockwiseDegs, anticlockwiseDegs, colour);\n            this.addBone(bone);\n        }\n        else {\n            throw new Error('You cannot add the base bone to a chain using this method as it does not provide a start location.');\n        }\n    };\n    FabrikChain2D.prototype.addConsecutiveBone = function (directionUV, length) {\n        this.addConsecutiveConstrainedBone(directionUV, length, 180.0, 180.0, new _utils_Colour4f__WEBPACK_IMPORTED_MODULE_3__[\"Colour4f\"]());\n    };\n    FabrikChain2D.prototype.addConsecutiveCreatedBone = function (bone) {\n        var dir = bone.getDirectionUV();\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"Utils\"].validateDirectionUV(dir);\n        var len = bone.getLength();\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"Utils\"].validateLength(len);\n        if (this._chain.length !== 0) {\n            var prevBoneEnd = this._chain[this._chain.length - 1].getEndLocation();\n            bone.setStartLocation(prevBoneEnd);\n            bone.setEndLocation(prevBoneEnd.plus(dir.times(len)));\n            this.addBone(bone);\n        }\n        else {\n            throw new Error('You cannot add the base bone to a chain using this method as it does not provide a start location.');\n        }\n    };\n    FabrikChain2D.prototype.getBaseboneConstraintType = function () { return this._baseboneConstraintType; };\n    FabrikChain2D.prototype.getBaseboneConstraintUV = function () { return this._baseboneConstraintUV; };\n    FabrikChain2D.prototype.getBaseLocation = function () {\n        if (this._chain.length !== 0) {\n            return this._chain[0].getStartLocation();\n        }\n        else {\n            throw new Error('Cannot get base location as there are zero bones in the chain.');\n        }\n    };\n    FabrikChain2D.prototype.getBone = function (boneNumber) {\n        return this._chain[boneNumber];\n    };\n    FabrikChain2D.prototype.getBoneConnectionPoint = function () { return this._boneConnectionPoint; };\n    FabrikChain2D.prototype.getChain = function () { return this._chain; };\n    FabrikChain2D.prototype.getChainLength = function () { return this._chainLength; };\n    FabrikChain2D.prototype.getConnectedBoneNumber = function () { return this._connectedBoneNumber; };\n    FabrikChain2D.prototype.getConnectedChainNumber = function () { return this._connectedChainNumber; };\n    FabrikChain2D.prototype.getEffectorLocation = function () {\n        if (this._chain.length !== 0) {\n            return this._chain[this._chain.length - 1].getEndLocation();\n        }\n        else {\n            throw new Error('Cannot get effector location as there are zero bones in the chain.');\n        }\n    };\n    FabrikChain2D.prototype.getEmbeddedTargetMode = function () { return this._useEmbeddedTarget; };\n    FabrikChain2D.prototype.getEmbeddedTarget = function () { return this._embeddedTarget; };\n    FabrikChain2D.prototype.getLastTargetLocation = function () { return this._lastTargetLocation; };\n    FabrikChain2D.prototype.getName = function () { return this._name; };\n    FabrikChain2D.prototype.getNumBones = function () { return this._chain.length; };\n    FabrikChain2D.prototype.removeBone = function (boneNumber) {\n        if (boneNumber < this._chain.length) {\n            this._chain.splice(boneNumber, 1);\n            this.updateChainLength();\n        }\n        else {\n            throw new Error('Bone ' + boneNumber + ' does not exist to be removed from the chain. Bones are zero indexed.');\n        }\n    };\n    FabrikChain2D.prototype.setBaseboneConstraintType = function (type) { this._baseboneConstraintType = type; };\n    FabrikChain2D.prototype.setBaseboneConstraintUV = function (constraintUV) {\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_4__[\"Utils\"].validateDirectionUV(constraintUV);\n        this._baseboneConstraintUV.set(_utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].normalised(constraintUV));\n    };\n    FabrikChain2D.prototype.setBaseLocation = function (baseLocation) {\n        this._baseLocation.set(baseLocation);\n    };\n    FabrikChain2D.prototype.setBoneConnectionPoint = function (boneConnectionPoint) { this._boneConnectionPoint = boneConnectionPoint; };\n    FabrikChain2D.prototype.setChain = function (chain) {\n        this._chain = chain;\n    };\n    FabrikChain2D.prototype.setColour = function (colour) {\n        for (var _i = 0, _a = this._chain; _i < _a.length; _i++) {\n            var aBone = _a[_i];\n            aBone.setColour(colour);\n        }\n    };\n    FabrikChain2D.prototype.setConnectedBoneNumber = function (boneNumber) {\n        this._connectedBoneNumber = boneNumber;\n    };\n    FabrikChain2D.prototype.setConnectedChainNumber = function (chainNumber) {\n        this._connectedChainNumber = chainNumber;\n    };\n    FabrikChain2D.prototype.setFixedBaseMode = function (value) {\n        if (!value && this._connectedChainNumber !== -1) {\n            throw new Error('This chain is connected to another chain so must remain in fixed base mode.');\n        }\n        if (this._baseboneConstraintType === _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_6__[\"BaseboneConstraintType2D\"].GLOBAL_ABSOLUTE && !value) {\n            throw new Error('Cannot set a non-fixed base mode when the chain\\'s constraint type is BaseBoneConstraintType2D.GLOBAL_ABSOLUTE.');\n        }\n        this._fixedBaseMode = value;\n    };\n    FabrikChain2D.prototype.setMaxIterationAttempts = function (maxIterations) {\n        if (maxIterations < 1) {\n            throw new Error('The maximum number of attempts to solve this IK chain must be at least 1.');\n        }\n        this._maxIterationAttempts = maxIterations;\n    };\n    FabrikChain2D.prototype.setMinIterationChange = function (minIterationChange) {\n        if (minIterationChange < 0) {\n            throw new Error('The minimum iteration change value must be more than or equal to zero.');\n        }\n        this._minIterationChange = minIterationChange;\n    };\n    FabrikChain2D.prototype.setName = function (name) { this._name = name; };\n    FabrikChain2D.prototype.setSolveDistanceThreshold = function (solveDistance) {\n        if (solveDistance < 0.0) {\n            throw new Error('The solve distance threshold must be greater than or equal to zero.');\n        }\n        this._solveDistanceThreshold = solveDistance;\n    };\n    FabrikChain2D.prototype.solveIK = function (target) {\n        // ---------- Прямой проход от эффектора к основанию  -----------\n        for (var loop = this._chain.length - 1; loop >= 0; --loop) {\n            var thisBone = this._chain[loop];\n            var boneLength = thisBone.getLength();\n            if (loop !== this._chain.length - 1) {\n                var outerBone = this._chain[loop + 1];\n                var outerBoneOuterToInnerUV = outerBone.getDirectionUV().negated();\n                var thisBoneOuterToInnerUV = thisBone.getDirectionUV().negated();\n                var clockwiseConstraintDegs = outerBone.getJoint().getClockwiseConstraintDegs();\n                var antiClockwiseConstraintDegs = outerBone.getJoint().getAnticlockwiseConstraintDegs();\n                var constrainedUV = void 0;\n                if (this._chain[loop].getJointConstraintCoordinateSystem() == _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_5__[\"ConstraintCoordinateSystem\"].LOCAL) {\n                    constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneOuterToInnerUV, outerBoneOuterToInnerUV, clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                }\n                else {\n                    constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneOuterToInnerUV, thisBone.getGlobalConstraintUV().negated(), clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                }\n                var newStartLocation = thisBone.getEndLocation().plus(constrainedUV.times(boneLength));\n                thisBone.setStartLocation(newStartLocation);\n                if (loop > 0) {\n                    this._chain[loop - 1].setEndLocation(newStartLocation);\n                }\n            }\n            else {\n                thisBone.setEndLocation(target);\n                var thisBoneOuterToInnerUV = thisBone.getDirectionUV().negated();\n                var constrainedUV = void 0;\n                if (loop > 0) {\n                    var innerBoneOuterToInnerUV = this._chain[loop - 1].getDirectionUV().negated();\n                    var clockwiseConstraintDegs = thisBone.getJoint().getClockwiseConstraintDegs();\n                    var antiClockwiseConstraintDegs = thisBone.getJoint().getAnticlockwiseConstraintDegs();\n                    if (thisBone.getJoint().getConstraintCoordinateSystem() == _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_5__[\"ConstraintCoordinateSystem\"].LOCAL) {\n                        constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneOuterToInnerUV, innerBoneOuterToInnerUV, clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                    }\n                    else {\n                        constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneOuterToInnerUV, thisBone.getGlobalConstraintUV().negated(), clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                    }\n                }\n                else {\n                    if (thisBone.getJointConstraintCoordinateSystem() == _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_5__[\"ConstraintCoordinateSystem\"].LOCAL) {\n                        constrainedUV = thisBoneOuterToInnerUV;\n                    }\n                    else {\n                        constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneOuterToInnerUV, thisBone.getGlobalConstraintUV().negated(), thisBone.getClockwiseConstraintDegs(), thisBone.getAnticlockwiseConstraintDegs());\n                    }\n                }\n                var newStartLocation = thisBone.getEndLocation().plus(constrainedUV.times(boneLength));\n                thisBone.setStartLocation(newStartLocation);\n                if (loop > 0) {\n                    this._chain[loop - 1].setEndLocation(newStartLocation);\n                }\n            }\n        }\n        // ---------- Обратный проход от основания к эффектору -----------\n        for (var loop = 0; loop < this._chain.length; ++loop) {\n            var boneLength = this._chain[loop].getLength();\n            var thisBone = this._chain[loop];\n            if (loop !== 0) {\n                var previousBone = this._chain[loop - 1];\n                var thisBoneInnerToOuterUV = thisBone.getDirectionUV();\n                var prevBoneInnerToOuterUV = previousBone.getDirectionUV();\n                var clockwiseConstraintDegs = thisBone.getJoint().getClockwiseConstraintDegs();\n                var antiClockwiseConstraintDegs = thisBone.getJoint().getAnticlockwiseConstraintDegs();\n                var constrainedUV = void 0;\n                if (thisBone.getJointConstraintCoordinateSystem() == _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_5__[\"ConstraintCoordinateSystem\"].LOCAL) {\n                    constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneInnerToOuterUV, prevBoneInnerToOuterUV, clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                }\n                else {\n                    constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneInnerToOuterUV, thisBone.getGlobalConstraintUV(), clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                }\n                var newEndLocation = thisBone.getStartLocation().plus(constrainedUV.times(boneLength));\n                thisBone.setEndLocation(newEndLocation);\n                if (loop < this._chain.length - 1) {\n                    this._chain[loop + 1].setStartLocation(newEndLocation);\n                }\n            }\n            else {\n                if (this._fixedBaseMode) {\n                    this._chain[0].setStartLocation(this._baseLocation);\n                }\n                else {\n                    var boneZeroUV = this._chain[0].getDirectionUV();\n                    var boneZeroEndLocation = this._chain[0].getEndLocation();\n                    var newBoneZeroStartLocation = boneZeroEndLocation.minus(boneZeroUV.times(boneLength));\n                    this._chain[0].setStartLocation(newBoneZeroStartLocation);\n                }\n                if (this._baseboneConstraintType == _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_6__[\"BaseboneConstraintType2D\"].NONE) {\n                    var thisBoneInnerToOuterUV = thisBone.getDirectionUV();\n                    var newEndLocation = thisBone.getStartLocation().plus(thisBoneInnerToOuterUV.times(boneLength));\n                    this._chain[0].setEndLocation(newEndLocation);\n                    if (this._chain.length > 1) {\n                        this._chain[1].setStartLocation(newEndLocation);\n                    }\n                }\n                else {\n                    var thisBoneInnerToOuterUV = thisBone.getDirectionUV();\n                    var clockwiseConstraintDegs = thisBone.getJoint().getClockwiseConstraintDegs();\n                    var antiClockwiseConstraintDegs = thisBone.getJoint().getAnticlockwiseConstraintDegs();\n                    var constrainedUV = void 0;\n                    if (this._baseboneConstraintType === _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_6__[\"BaseboneConstraintType2D\"].LOCAL_ABSOLUTE) {\n                        constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneInnerToOuterUV, this._baseboneRelativeConstraintUV, clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                    }\n                    else {\n                        constrainedUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].getConstrainedUV(thisBoneInnerToOuterUV, this._baseboneConstraintUV, clockwiseConstraintDegs, antiClockwiseConstraintDegs);\n                    }\n                    var newEndLocation = this._chain[loop].getStartLocation().plus(constrainedUV.times(boneLength));\n                    this._chain[loop].setEndLocation(newEndLocation);\n                    if (loop < this._chain.length - 1) {\n                        this._chain[loop + 1].setStartLocation(newEndLocation);\n                    }\n                }\n            }\n        }\n        this._lastTargetLocation.set(target);\n        var currentEffectorLocation = this._chain[this._chain.length - 1].getEndLocation();\n        return _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].distanceBetween(currentEffectorLocation, target);\n    };\n    FabrikChain2D.prototype.setEmbeddedTargetMode = function (value) { this._useEmbeddedTarget = value; };\n    FabrikChain2D.prototype.cloneChainVector = function () {\n        var numBones = this._chain.length;\n        var clonedChain = [];\n        for (var loop = 0; loop < numBones; ++loop) {\n            var bone = new _FabrikBone2D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikBone2D\"]();\n            bone.set(this._chain[loop]);\n            clonedChain.push(bone);\n        }\n        return clonedChain;\n    };\n    FabrikChain2D.prototype.updateChainLength = function () {\n        this._chainLength = 0.0;\n        for (var _i = 0, _a = this._chain; _i < _a.length; _i++) {\n            var aBone = _a[_i];\n            this._chainLength += aBone.getLength();\n        }\n    };\n    FabrikChain2D.prototype.updateEmbeddedTarget = function (newEmbeddedTarget) {\n        if (this._useEmbeddedTarget) {\n            this._embeddedTarget.set(newEmbeddedTarget);\n        }\n        else {\n            throw new Error('This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true).');\n        }\n    };\n    FabrikChain2D.prototype.solveForEmbeddedTarget = function () {\n        if (this._useEmbeddedTarget) {\n            return this.solveForTarget(this._embeddedTarget);\n        }\n        else {\n            throw new Error('This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true).');\n        }\n    };\n    FabrikChain2D.prototype.solveForTarget = function (newTarget) {\n        if (this._lastTargetLocation.approximatelyEquals(newTarget, 0.001) && this._lastBaseLocation.approximatelyEquals(this._baseLocation, 0.001)) {\n            return this._currentSolveDistance;\n        }\n        var startingDistance;\n        var startingSolution = null;\n        if (this._lastBaseLocation.approximatelyEquals(this._baseLocation, 0.001)) {\n            startingDistance = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_1__[\"Vec2f\"].distanceBetween(this._chain[this._chain.length - 1].getEndLocation(), newTarget);\n            startingSolution = this.cloneChainVector();\n        }\n        else {\n            startingDistance = Number.MAX_VALUE;\n        }\n        var bestSolution = [];\n        var bestSolveDistance = Number.MAX_VALUE;\n        var lastPassSolveDistance = Number.MAX_VALUE;\n        var solveDistance;\n        for (var loop = 0; loop < this._maxIterationAttempts; ++loop) {\n            solveDistance = this.solveIK(newTarget);\n            if (solveDistance < bestSolveDistance) {\n                bestSolveDistance = solveDistance;\n                bestSolution = this.cloneChainVector();\n                if (solveDistance <= this._solveDistanceThreshold) {\n                    break;\n                }\n            }\n            else {\n                if (Math.abs(solveDistance - lastPassSolveDistance) < this._minIterationChange) {\n                    break;\n                }\n            }\n            lastPassSolveDistance = solveDistance;\n        }\n        if (bestSolveDistance < startingDistance) {\n            this._currentSolveDistance = bestSolveDistance;\n            this._chain = bestSolution;\n        }\n        else {\n            this._currentSolveDistance = startingDistance;\n            this._chain = startingSolution;\n        }\n        this._lastBaseLocation.set(this._baseLocation);\n        this._lastTargetLocation.set(newTarget);\n        return this._currentSolveDistance;\n    };\n    FabrikChain2D.prototype.getBaseboneRelativeConstraintUV = function () { return this._baseboneRelativeConstraintUV; };\n    FabrikChain2D.prototype.setBaseboneRelativeConstraintUV = function (constraintUV) { this._baseboneRelativeConstraintUV.set(constraintUV); };\n    FabrikChain2D.prototype.getMaxIterationAttempts = function () {\n        return this._maxIterationAttempts;\n    };\n    FabrikChain2D.prototype.getMinIterationChange = function () {\n        return this._minIterationChange;\n    };\n    FabrikChain2D.prototype.getSolveDistanceThreshold = function () {\n        return this._solveDistanceThreshold;\n    };\n    return FabrikChain2D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikChain2D.ts?");

/***/ }),

/***/ "./src/main/FabrikChain3D.ts":
/*!***********************************!*\
  !*** ./src/main/FabrikChain3D.ts ***!
  \***********************************/
/*! exports provided: FabrikChain3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikChain3D\", function() { return FabrikChain3D; });\n/* harmony import */ var _FabrikBone3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FabrikBone3D */ \"./src/main/FabrikBone3D.ts\");\n/* harmony import */ var _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FabrikJoint3D */ \"./src/main/FabrikJoint3D.ts\");\n/* harmony import */ var _JointType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JointType */ \"./src/main/JointType.ts\");\n/* harmony import */ var _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Vec3f */ \"./src/utils/Vec3f.ts\");\n/* harmony import */ var _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BaseboneConstraintType3D */ \"./src/main/BaseboneConstraintType3D.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n/* harmony import */ var _utils_Colour4f__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/Colour4f */ \"./src/utils/Colour4f.ts\");\n/* harmony import */ var _utils_Mat3f__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/Mat3f */ \"./src/utils/Mat3f.ts\");\n\n\n\n\n\n\n\n\n/**\n * 3D цепь костей, решающая задачу инверсной кинематики с помощью алгоритма FABRIK.\n */\nvar FabrikChain3D = /** @class */ (function () {\n    // ---------- Constructors ----------\n    /**\n     * Конструктор.\n     *\n     * Принимает три вариации параметров:\n     *\n     * Без параметров. Всем полям проставляются значения по умолчанию.\n     *\n     * Один параметр-строка.\n     *\n     * @param    source    Имя данной цепи.\n     *\n     * Конструктор копирования.\n     *\n     * @param    source    Цепь для копирования.\n     */\n    function FabrikChain3D(source) {\n        var _this = this;\n        // ---------- Private Properties ----------\n        /**\n         * Массив костей цепи.\n         */\n        this._chain = [];\n        /**\n         * Порог, достигнув которого мы считаем задачу инверсной кинематики решенной.\n         * <p>\n         * При решении задачи ИК, когда расстояние между текущим положением и желаемым положением становится меньше или равно\n         * значению порога, мы прерываем дальнейшие итерации и считаем задачу решенной.\n         * <p>\n         * Значение по умолчанию 0.01.\n         * <p>\n         * Минимально допустимое значение - 0, но стоит помнить о погрешности вычисления и не задавать порог равным нулю, так\n         * как это может привести к бесконечным бесполезным попыткам.\n         * <p>\n         * Хотя данное поле и самый важный критерий останова для ИК-алгоритма, оно работает в комбинации с\n         * {@link #_maxIterationAttempts} и {@link _minIterationChange}. Эти вспомогательные свойства помогают пережить ситуации,\n         * когда длины цепи не хватает для достижения цели или когда суставы цепи сильно ограничены.\n         */\n        this._solveDistanceThreshold = 0.01;\n        /**\n         * Максимальное количество итераций алгоритма, применяемых при решении задачи ИК.\n         *\n         * @default 20\n         */\n        this._maxIterationAttempts = 20;\n        /**\n         * Минимальное значения для дельты рассотояний между итерациями алгоритма.\n         *\n         * @default 0.01\n         */\n        this._minIterationChange = 0.01;\n        /**\n         * Начальная позиция первой кости в цепи.\n         *\n         * @default: Vec3f(0, 0)\n         */\n        this._fixedBaseLocation = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"]();\n        /**\n         * Зафиксирована ли начальная позиция цепи.\n         * Если нет - то она может перемещаться.\n         *\n         * @default true\n         */\n        this._fixedBaseMode = true;\n        /**\n         * Тип сустава первой кости в цепи.\n         */\n        this._baseboneConstraintType = _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].NONE;\n        /**\n         * Направление относительно которого мы ограничиваем первую кость цепи.\n         */\n        this._baseboneConstraintUV = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"]();\n        this._baseboneRelativeConstraintUV = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"]();\n        this._baseboneRelativeReferenceConstraintUV = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"]();\n        /**\n         * Последняя целевая позиция, относительно которой решалась задача ИК.\n         *\n         * @default Vec3f(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)\n         */\n        this._lastTargetLocation = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        /**\n         * Предыдущая начальная позиция базовой (первой в цепи) кости.\n         * <p>\n         * Данное значение хранится для того, чтобы сравнивать изменилось ли\n         * начальное положение базовой кости в процессе решения.\n         *\n         * @default Vec3f(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)\n         */\n        this._lastBaseLocation = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        /**\n         * Текущее расстояние между эффектором(концом последней точки в цепи) и целевой позицией.\n         */\n        this._currentSolveDistance = Number.MAX_VALUE;\n        /**\n         * Номер цепи, к которой эта цепь подключена в FabrikStructure3D.\n         * <p>\n         * Если значение -1, значит данная цепь ни с чем не связана.\n         *\n         * @default -1\n         */\n        this._connectedChainNumber = -1;\n        /**\n         * Номер кости, с которой связана эта цепь, если она вообще связана с другой цепью.\n         * <p>\n         * Если значение -1, значит данная цепь ни с чем не связана.\n         *\n         * @default -1\n         */\n        this._connectedBoneNumber = -1;\n        /**\n         * Встроенное целевое расположение,которое можно использовать для решения ИК.\n         * <p>\n         * Встроенные целевые местоположения позволяют решать ИК структуры для нескольких целей (по одной на цепочку в структуре)\n         * вместо того, чтобы все цепочки решались для одной и той же цели. Чтобы использовать встроенные цели, флаг _useEmbeddedTargets\n         * должно быть true(что не является значением по умолчанию) - этот флаг можно установить с помощью вызова setEmbeddedTargetMode (true).\n         *\n         * @see {@link setEmbeddedTargetMode(boolean) }\n         */\n        this._embeddedTarget = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"]();\n        /**\n         * _useEmbeddedTarget    Следует ли использовать местоположение _embeddedTarget при решении этой цепочки.\n         * <p>\n         * Этот флаг можно переключить, вызвав setEmbeddedTargetMode (true) в цепочке.\n         *\n         * @default false\n         * @see {@link setEmbeddedTargetMode(boolean) }\n         */\n        this._useEmbeddedTarget = false;\n        /**\n         * Возвращает относительный единичный вектор основной кости этой цепочки.\n         *\n         * @return\n         */\n        this.getBaseboneRelativeConstraintUV = function () { return _this._baseboneRelativeConstraintUV; };\n        /**\n         * Возвращает тип сустава базовой кости.\n         *\n         * @return\n         */\n        this.getBaseboneConstraintType = function () { return _this._baseboneConstraintType; };\n        /**\n         * Возвращает базовое расположение цепочки IK.\n         * <p>\n         * Независимо от того, сколько костей содержится в цепи, базовое местоположение всегда является начальным местоположением\n         * первой кости в цепи.\n         *\n         * @return\n         */\n        this.getBaseLocation = function () { return _this._chain[0].getStartLocation(); };\n        /**\n         * Возвращает кость цепи по индексу.\n         *\n         * @param    boneNumber    Индекс кости.\n         * @return                Кость.\n         */\n        this.getBone = function (boneNumber) { return _this._chain[boneNumber]; };\n        /**\n         * Возвращает длину цепи.\n         *\n         * @return\n         */\n        this.getChainLength = function () { return _this._chainLength; };\n        /**\n         * Возвращает индекс кости из другой цепи, к которой присоединена наша цепь.\n         * <p>\n         * Возвращает -1 если мы ни к кому не присоединены.\n         *\n         * @return\n         */\n        this.getConnectedBoneNumber = function () { return _this._connectedBoneNumber; };\n        /**\n         * Возвращает индекс цепи в структуре, к которой присоединена наша цепь.\n         * <p>\n         * Возвращает -1 если мы ни к кому не присоединены.\n         *\n         * @return\n         */\n        this.getConnectedChainNumber = function () { return _this._connectedChainNumber; };\n        /**\n         * Возврат внедренного целевого местоположения.\n         *\n         * @return\n         */\n        this.getEmbeddedTarget = function () { return _this._embeddedTarget; };\n        /**\n         * Возвращает цель последней попытки решения.\n         * <p>\n         * Целевое местоположение и местоположение эффектора не обязательно находятся в одном и том же месте.\n         *\n         * @return\n         */\n        this.getLastTargetLocation = function () { return _this._lastTargetLocation; };\n        /**\n         * Возвращает название этой ИК цепи.\n         *\n         * @return\n         */\n        this.getName = function () { return _this._name; };\n        /**\n         * Возвращает количество костей в цепи.\n         *\n         * @return\n         */\n        this.getNumBones = function () { return _this._chain.length; };\n        this.getBaseboneRelativeReferenceConstraintUV = function () { return _this._baseboneRelativeReferenceConstraintUV; };\n        if (!source) {\n            return;\n        }\n        if (typeof source === 'string') {\n            this._name = source;\n        }\n        else {\n            this._chain = source.cloneIkChain();\n            this._fixedBaseLocation.set(source.getBaseLocation());\n            this._lastTargetLocation.set(source._lastTargetLocation);\n            this._lastBaseLocation.set(source._lastBaseLocation);\n            this._embeddedTarget.set(source._embeddedTarget);\n            if (source._baseboneConstraintType != _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].NONE) {\n                this._baseboneConstraintUV.set(source._baseboneConstraintUV);\n                this._baseboneRelativeConstraintUV.set(source._baseboneRelativeConstraintUV);\n            }\n            this._chainLength = source._chainLength;\n            this._currentSolveDistance = source._currentSolveDistance;\n            this._connectedChainNumber = source._connectedChainNumber;\n            this._connectedBoneNumber = source._connectedBoneNumber;\n            this._baseboneConstraintType = source._baseboneConstraintType;\n            this._name = source._name;\n            this._useEmbeddedTarget = source._useEmbeddedTarget;\n        }\n    }\n    // ---------- Public Methods ------------\n    /**\n     * Добавляет кость в конец цепи.\n     *\n     * @param    bone    Кость.\n     */\n    FabrikChain3D.prototype.addBone = function (bone) {\n        this._chain.push(bone);\n        if (this._chain.length == 1) {\n            this._fixedBaseLocation.set(bone.getStartLocation());\n            this._baseboneConstraintUV = bone.getDirectionUV();\n        }\n        this.updateChainLength();\n    };\n    /***\n     * Добавляет последовательную кость в конец этой цепи IK с учетом вектора направления и длины новой кости.\n     * <p>\n     * Добавленная кость не имеет каких-либо ограничений.\n     * <p>\n     * Этот метод можно использовать только тогда, когда цепь IK содержит базовую кость, так как без нее у нас нет\n     * начального местоположения для этой кости (т. е. конечного местоположения предыдущей).\n     * <p>\n     * Если этот метод выполняется в цепочке, которая не содержит основной кости, то возбуждается ошибка.\n     * <p>\n     * Если вектор направления или длина равны нулю, то возбуждается ошибка.\n     *\n     * @param    directionUV    Первоначальное направление новой кости.\n     * @param    length        Длина новой кости.\n     * @param    colour        Цвет для отрисовки новой кости.\n     * @param    name          Имя новой кости.\n     */\n    FabrikChain3D.prototype.addConsecutiveBone = function (directionUV, length, colour, name) {\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateDirectionUV(directionUV);\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateLength(length);\n        if (!(this._chain.length === 0)) {\n            var prevBoneEnd = this._chain[this._chain.length - 1].getEndLocation();\n            this.addBone(new _FabrikBone3D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikBone3D\"](prevBoneEnd, directionUV.normalised(), length, colour, name));\n        }\n        else {\n            throw new Error('You cannot add the basebone as a consecutive bone as it does not provide a start location. Use the addBone() method instead.');\n        }\n    };\n    /**\n     * Добавляет предварительно созданную последовательную кость к концу этой цепочки IK.\n     * <p>\n     * Этот метод можно использовать только тогда, когда цепь IK содержит базовую кость, так как без нее у нас нет\n     * начального местоположения для этой кости (т. е. конечного местоположения предыдущей).\n     * <p>\n     * Если этот метод выполняется в цепочке, которая не содержит основной кости,\n     * или кость, которую пытаются добавить имеет нулевую длину то возбуждается ошибка.\n     *\n     * @param    bone        Кость.\n     */\n    FabrikChain3D.prototype.addConsecutiveCreatedBone = function (bone) {\n        var dir = bone.getDirectionUV();\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateDirectionUV(dir);\n        var len = bone.getLength();\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateLength(len);\n        if (!(this._chain.length === 0)) {\n            var prevBoneEnd = this._chain[this._chain.length - 1].getEndLocation();\n            bone.setStartLocation(prevBoneEnd);\n            bone.setEndLocation(prevBoneEnd.plus(dir.times(len)));\n            this.addBone(bone);\n        }\n        else {\n            throw new Error('You cannot add the base bone to a chain using this method as it does not provide a start location.');\n        }\n    };\n    /**\n     * Добавляет последовательную шарнирную кость к концу этой цепи IK.\n     * <p>\n     * Тип шарнира может быть глобальным, ось вращения которого указана в мировом пространстве, или\n     * локальным, ось вращения которого расположена относительно предыдущей кости в цепи.\n     * <p>\n     * Если этот метод выполняется в цепочке, которая не содержит основной кости, возникает ошибка.\n     * Если направление кости или ось ограничения шарнира нули, возникает ошибка.\n     * Если запрошенный тип соединения не является LOCAL_HINGE или GLOBAL_HINGE, возникает ошибка.\n     *\n     * @param    directionUV            Начальное направление новой кости.\n     * @param    length                Длина новой кости.\n     * @param    jointType            Тип сустава новой кости.\n     * @param    hingeRotationAxis    Ось вращения шарнира.\n     * @param    clockwiseDegs        Угол-ограничение по часовой стрелке в градусах.\n     * @param    anticlockwiseDegs    Угол-ограничение против часовой стрелки в градусах.\n     * @param    hingeReferenceAxis    Ось относительно которой ведется отсчет угла поворота шарнира.\n     * @param    colour                Цвет новой кости.\n     */\n    FabrikChain3D.prototype.addConsecutiveHingedBone = function (directionUV, length, jointType, hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeReferenceAxis, colour) {\n        if (clockwiseDegs === void 0) { clockwiseDegs = 180; }\n        if (anticlockwiseDegs === void 0) { anticlockwiseDegs = 180; }\n        if (hingeReferenceAxis === void 0) { hingeReferenceAxis = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].genPerpendicularVectorQuick(hingeRotationAxis); }\n        if (colour === void 0) { colour = new _utils_Colour4f__WEBPACK_IMPORTED_MODULE_6__[\"Colour4f\"](); }\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateDirectionUV(directionUV);\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateDirectionUV(hingeRotationAxis);\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateLength(length);\n        if (this._chain.length === 0) {\n            throw new Error('You must add a basebone before adding a consectutive bone.');\n        }\n        directionUV.normalise();\n        hingeRotationAxis.normalise();\n        var prevBoneEnd = this._chain[this._chain.length - 1].getEndLocation();\n        var bone = new _FabrikBone3D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikBone3D\"](prevBoneEnd, directionUV, length, colour);\n        var joint = new _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"]();\n        switch (jointType) {\n            case _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].GLOBAL_HINGE:\n                joint.setHingeJoint(_JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].GLOBAL_HINGE, hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeReferenceAxis);\n                break;\n            case _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].LOCAL_HINGE:\n                joint.setHingeJoint(_JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].LOCAL_HINGE, hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeReferenceAxis);\n                break;\n            default:\n                throw new Error('Hinge joint types may be only JointType.GLOBAL_HINGE or JointType.LOCAL_HINGE.');\n        }\n        bone.setJoint(joint);\n        this.addBone(bone);\n    };\n    /**\n     * Добавляет последовательный шаровой сустав, ограничивающий кость, к концу этой цепи IK.\n     * <p>\n     * Этот метод можно использовать только тогда, когда цепь IK содержит базовую кость, так как без нее у нас нет\n     * начального местоположения для этой кости (т. е. конечного местоположения предыдущей).\n     * <p>\n     * Если этот метод выполняется в цепочке, которая не содержит основной кости,\n     * или кость, которую пытаются добавить имеет нулевую длину то возбуждается ошибка.\n     *\n     * @param    boneDirectionUV                    Начальное направление единичного вектора новой кости.\n     * @param    boneLength                        Длина новой кости.\n     * @param    constraintAngleDegs                Угол ограничение.\n     * @param    colour                            Цвет для отрисовки новой кости.\n     */\n    FabrikChain3D.prototype.addConsecutiveRotorConstrainedBone = function (boneDirectionUV, boneLength, constraintAngleDegs, colour) {\n        if (constraintAngleDegs === void 0) { constraintAngleDegs = 180; }\n        if (colour === void 0) { colour = new _utils_Colour4f__WEBPACK_IMPORTED_MODULE_6__[\"Colour4f\"](); }\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateDirectionUV(boneDirectionUV);\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateLength(boneLength);\n        if (this._chain.length === 0) {\n            throw new Error('Add a basebone before attempting to add consectuive bones.');\n        }\n        var bone = new _FabrikBone3D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikBone3D\"](this._chain[this._chain.length - 1].getEndLocation(), boneDirectionUV.normalise(), boneLength, colour);\n        bone.setBallJointConstraintDegs(constraintAngleDegs);\n        this.addBone(bone);\n    };\n    /**\n     * Возвращает ограничение направления основной кости.\n     * <p>\n     * Если базовая кость не ограничена, то возникает ошибка. Если вы хотите проверить, ограничена ли\n     * базовая кость этой цепочки ИК вы можете использовать метод {@link #getBaseboneConstraintType()}.\n     *\n     * @return\n     */\n    FabrikChain3D.prototype.getBaseboneConstraintUV = function () {\n        if (this._baseboneConstraintType != _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].NONE) {\n            return this._baseboneConstraintUV;\n        }\n        else {\n            throw new Error('Cannot return the basebone constraint when the basebone constraint type is NONE.');\n        }\n    };\n    /**\n     * Возвращает массив костей цепи.\n     *\n     * @return\n     */\n    FabrikChain3D.prototype.getChain = function () {\n        return this._chain;\n    };\n    /**\n     * Возвращает эффектор.\n     * <p>\n     * Независимо от того, сколько костей содержится в цепи, эффектор - это всегда конец\n     * последней кости в цепи.\n     *\n     * @return\n     */\n    FabrikChain3D.prototype.getEffectorLocation = function () {\n        return this._chain[this._chain.length - 1].getEndLocation();\n    };\n    /**\n     * Возвращает должна ли цепь использовать встроенное целевое положение.\n     *\n     * @return\n     */\n    FabrikChain3D.prototype.getEmbeddedTargetMode = function () {\n        return this._useEmbeddedTarget;\n    };\n    /**\n     * Удаляет кость из этой цепи IK по ее индексу в цепи.\n     * <p>\n     * Если номер кости, которую необходимо удалить, не существует в цепочке, то возникает ошибка.\n     *\n     * @param    boneNumber    Индекс кости в цепи.\n     */\n    FabrikChain3D.prototype.removeBone = function (boneNumber) {\n        if (boneNumber < this._chain.length) {\n            this._chain.splice(boneNumber, 1);\n            this.updateChainLength();\n        }\n        else {\n            throw new Error('Bone ' + boneNumber + ' does not exist to be removed from the chain. Bones are zero indexed.');\n        }\n    };\n    FabrikChain3D.prototype._setBaseboneRelativeConstraintUV = function (constraintUV) {\n        this._baseboneRelativeConstraintUV = constraintUV;\n    };\n    FabrikChain3D.prototype._setBaseboneRelativeReferenceConstraintUV = function (constraintUV) {\n        this._baseboneRelativeReferenceConstraintUV = constraintUV;\n    };\n    /**\n     * Устанавливает должна ли использоваться встроенная целевая позиция.\n     *\n     * @param    value\n     */\n    FabrikChain3D.prototype.setEmbeddedTargetMode = function (value) {\n        this._useEmbeddedTarget = value;\n    };\n    FabrikChain3D.prototype.setRotorBaseboneConstraint = function (rotorType, constraintAxis, angleDegs) {\n        if (this._chain.length === 0) {\n            throw new Error('Chain must contain a basebone before we can specify the basebone constraint type.');\n        }\n        if (constraintAxis.length() <= 0.0) {\n            throw new Error('Constraint axis cannot be zero.');\n        }\n        if (angleDegs < 0.0) {\n            angleDegs = 0.0;\n        }\n        if (angleDegs > 180.0) {\n            angleDegs = 180.0;\n        }\n        if (!(rotorType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].GLOBAL_ROTOR || rotorType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].LOCAL_ROTOR)) {\n            throw new Error('The only valid rotor types for this method are GLOBAL_ROTOR and LOCAL_ROTOR.');\n        }\n        this._baseboneConstraintType = rotorType;\n        this._baseboneConstraintUV = constraintAxis.normalised();\n        this._baseboneRelativeConstraintUV.set(this._baseboneConstraintUV);\n        this.getBone(0).getJoint().setAsBallJoint(angleDegs);\n    };\n    FabrikChain3D.prototype.setHingeBaseboneConstraint = function (hingeType, hingeRotationAxis, cwConstraintDegs, acwConstraintDegs, hingeReferenceAxis) {\n        if (this._chain.length === 0) {\n            throw new Error('Chain must contain a basebone before we can specify the basebone constraint type.');\n        }\n        if (hingeRotationAxis.length() <= 0.0) {\n            throw new Error('Hinge rotation axis cannot be zero.');\n        }\n        if (hingeReferenceAxis.length() <= 0.0) {\n            throw new Error('Hinge reference axis cannot be zero.');\n        }\n        if (!(_utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].perpendicular(hingeRotationAxis, hingeReferenceAxis))) {\n            throw new Error('The hinge reference axis must be in the plane of the hinge rotation axis, that is, they must be perpendicular.');\n        }\n        if (!(hingeType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].GLOBAL_HINGE || hingeType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].LOCAL_HINGE)) {\n            throw new Error('The only valid hinge types for this method are GLOBAL_HINGE and LOCAL_HINGE.');\n        }\n        this._baseboneConstraintType = hingeType;\n        this._baseboneConstraintUV.set(hingeRotationAxis.normalised());\n        var hinge = new _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"]();\n        if (hingeType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].GLOBAL_HINGE) {\n            hinge.setHingeJoint(_JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].GLOBAL_HINGE, hingeRotationAxis, cwConstraintDegs, acwConstraintDegs, hingeReferenceAxis);\n        }\n        else {\n            hinge.setHingeJoint(_JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].LOCAL_HINGE, hingeRotationAxis, cwConstraintDegs, acwConstraintDegs, hingeReferenceAxis);\n        }\n        this.getBone(0).setJoint(hinge);\n    };\n    FabrikChain3D.prototype.setBaseboneConstraintUV = function (constraintUV) {\n        if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].NONE) {\n            throw new Error('Specify the basebone constraint type with setBaseboneConstraintTypeCannot specify a basebone constraint when the current constraint type is BaseboneConstraint.NONE.');\n        }\n        _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].validateDirectionUV(constraintUV);\n        constraintUV.normalise();\n        this._baseboneConstraintUV.set(constraintUV);\n    };\n    FabrikChain3D.prototype.setBaseLocation = function (baseLocation) {\n        this._fixedBaseLocation.set(baseLocation);\n    };\n    /**\n     * Присоединяет цепь к кости из другой цепи.\n     * <p>\n     * Чтобы соединить эту цепь с другой цепью, обе цепи должны существовать в одной и той же структуре.\n     * <p>\n     * Если структура не содержит указанную цепь или кость, то возникает ошибка.\n     *\n     * @param    structure    Структура, в которой произойдёт соединение.\n     * @param    chainNumber    Индекс цепи для присоединения.\n     * @param    boneNumber    Индекс кости к которой мы присоединяемся.\n     */\n    FabrikChain3D.prototype.connectToStructure = function (structure, chainNumber, boneNumber) {\n        var nu_chains = structure.getNumChains();\n        if (chainNumber > nu_chains) {\n            throw new Error('Structure does not contain a chain ' + chainNumber + ' - it has ' + nu_chains + ' chains.');\n        }\n        var numBones = structure.getChain(chainNumber).getNumBones();\n        if (boneNumber > numBones) {\n            throw new Error('Chain does not contain a bone ' + boneNumber + ' - it has ' + numBones + ' bones.');\n        }\n        this._connectedChainNumber = chainNumber;\n        this._connectedBoneNumber = boneNumber;\n    };\n    FabrikChain3D.prototype.setFixedBaseMode = function (value) {\n        if (!value && this._connectedChainNumber != -1) {\n            throw new Error('This chain is connected to another chain so must remain in fixed base mode.');\n        }\n        if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].GLOBAL_ROTOR && !value) {\n            throw new Error('Cannot set a non-fixed base mode when the chain\\'s constraint type is BaseboneConstraintType3D.GLOBAL_ABSOLUTE_ROTOR.');\n        }\n        this._fixedBaseMode = value;\n    };\n    FabrikChain3D.prototype.setMaxIterationAttempts = function (maxIterations) {\n        if (maxIterations < 1) {\n            throw new Error('The maximum number of attempts to solve this IK chain must be at least 1.');\n        }\n        this._maxIterationAttempts = maxIterations;\n    };\n    FabrikChain3D.prototype.setMinIterationChange = function (minIterationChange) {\n        if (minIterationChange < 0.0) {\n            throw new Error('The minimum iteration change value must be more than or equal to zero.');\n        }\n        this._minIterationChange = minIterationChange;\n    };\n    FabrikChain3D.prototype.setName = function (name) {\n        this._name = name;\n    };\n    FabrikChain3D.prototype.setSolveDistanceThreshold = function (solveDistance) {\n        if (solveDistance < 0.0) {\n            throw new Error('The solve distance threshold must be greater than or equal to zero.');\n        }\n        this._solveDistanceThreshold = solveDistance;\n    };\n    /**\n     * Set the colour of all bones in this chain to the specified colour.\n     *\n     * @param    colour    The colour to set all bones in this chain.\n     */\n    FabrikChain3D.prototype.setColour = function (colour) {\n        for (var _i = 0, _a = this._chain; _i < _a.length; _i++) {\n            var aBone = _a[_i];\n            aBone.setColour(colour);\n        }\n    };\n    FabrikChain3D.prototype.solveForEmbeddedTarget = function () {\n        if (this._useEmbeddedTarget) {\n            return this.solveForTarget(this._embeddedTarget);\n        }\n        else {\n            throw new Error('This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true).');\n        }\n    };\n    FabrikChain3D.prototype.solveForTarget = function (newTarget) {\n        if (this._lastTargetLocation.approximatelyEquals(newTarget, 0.00001) &&\n            (!this._fixedBaseMode && this._lastBaseLocation.approximatelyEquals(this.getBaseLocation(), 0.00001)) &&\n            (this._fixedBaseMode && this._fixedBaseLocation.approximatelyEquals(this.getBaseLocation(), 0.00001))) {\n            return this._currentSolveDistance;\n        }\n        var bestSolution = [];\n        var bestSolveDistance = Number.MAX_VALUE;\n        var lastPassSolveDistance = Number.MAX_VALUE;\n        var solveDistance;\n        for (var loop = 0; loop < this._maxIterationAttempts; ++loop) {\n            solveDistance = this.solveIK(newTarget);\n            if (solveDistance < bestSolveDistance) {\n                bestSolveDistance = solveDistance;\n                bestSolution = this.cloneIkChain();\n                if (solveDistance <= this._solveDistanceThreshold) {\n                    break;\n                }\n            }\n            else {\n                if (Math.abs(solveDistance - lastPassSolveDistance) < this._minIterationChange) {\n                    break;\n                }\n            }\n            lastPassSolveDistance = solveDistance;\n        }\n        this._currentSolveDistance = bestSolveDistance;\n        this._chain = bestSolution;\n        this._lastBaseLocation.set(this.getBaseLocation());\n        this._lastTargetLocation.set(newTarget);\n        return this._currentSolveDistance;\n    };\n    // ---------- Private Methods ----------\n    /**\n     * Решает задачу ИК с помощью алгоритма FABRIK.\n     * <p>\n     * Если в цепи еще нет костей - возникнет ошибка.\n     *\n     * @param target    Целевое местоположение.\n     * @return            Наименьшее расстояние между новым положением эффектора и целевым местоположением, которого удалось достичь.\n     */\n    FabrikChain3D.prototype.solveIK = function (target) {\n        if (this._chain.length === 0) {\n            throw new Error('It makes no sense to solve an IK chain with zero bones.');\n        }\n        // ---------- ПРЯМОЙ ПРОХОД: от эффектора к базовой кости -----------\n        for (var loop = this._chain.length - 1; loop >= 0; --loop) {\n            var thisBone = this._chain[loop];\n            var thisBoneLength = thisBone.getLength();\n            var thisBoneJoint = thisBone.getJoint();\n            var thisBoneJointType = thisBone.getJointType();\n            if (loop != this._chain.length - 1) {\n                var outerBoneOuterToInnerUV = this._chain[loop + 1].getDirectionUV().negated();\n                var thisBoneOuterToInnerUV = thisBone.getDirectionUV().negated();\n                if (thisBoneJointType == _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].BALL) {\n                    var angleBetweenDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleBetweenDegs(outerBoneOuterToInnerUV, thisBoneOuterToInnerUV);\n                    var constraintAngleDegs = thisBoneJoint.getBallJointConstraintDegs();\n                    if (angleBetweenDegs > constraintAngleDegs) {\n                        thisBoneOuterToInnerUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleLimitedUnitVectorDegs(thisBoneOuterToInnerUV, outerBoneOuterToInnerUV, constraintAngleDegs);\n                    }\n                }\n                else if (thisBoneJointType == _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].GLOBAL_HINGE) {\n                    thisBoneOuterToInnerUV = thisBoneOuterToInnerUV.projectOntoPlane(thisBoneJoint.getHingeRotationAxis());\n                }\n                else if (thisBoneJointType == _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].LOCAL_HINGE) {\n                    var m = void 0;\n                    var relativeHingeRotationAxis = void 0;\n                    if (loop > 0) {\n                        m = _utils_Mat3f__WEBPACK_IMPORTED_MODULE_7__[\"Mat3f\"].createRotationMatrix(this._chain[loop - 1].getDirectionUV());\n                        relativeHingeRotationAxis = m.times(thisBoneJoint.getHingeRotationAxis()).normalise();\n                    }\n                    else {\n                        relativeHingeRotationAxis = this._baseboneRelativeConstraintUV;\n                    }\n                    thisBoneOuterToInnerUV = thisBoneOuterToInnerUV.projectOntoPlane(relativeHingeRotationAxis);\n                }\n                var newStartLocation = thisBone.getEndLocation().plus(thisBoneOuterToInnerUV.times(thisBoneLength));\n                thisBone.setStartLocation(newStartLocation);\n                if (loop > 0) {\n                    this._chain[loop - 1].setEndLocation(newStartLocation);\n                }\n            }\n            else {\n                thisBone.setEndLocation(target);\n                var thisBoneOuterToInnerUV = thisBone.getDirectionUV().negated();\n                switch (thisBoneJointType) {\n                    case _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].BALL:\n                        break;\n                    case _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].GLOBAL_HINGE:\n                        thisBoneOuterToInnerUV = thisBoneOuterToInnerUV.projectOntoPlane(thisBoneJoint.getHingeRotationAxis());\n                        break;\n                    case _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].LOCAL_HINGE:\n                        var m = _utils_Mat3f__WEBPACK_IMPORTED_MODULE_7__[\"Mat3f\"].createRotationMatrix(this._chain[loop - 1].getDirectionUV());\n                        var relativeHingeRotationAxis = m.times(thisBoneJoint.getHingeRotationAxis()).normalise();\n                        thisBoneOuterToInnerUV = thisBoneOuterToInnerUV.projectOntoPlane(relativeHingeRotationAxis);\n                        break;\n                }\n                var newStartLocation = target.plus(thisBoneOuterToInnerUV.times(thisBoneLength));\n                thisBone.setStartLocation(newStartLocation);\n                if (loop > 0) {\n                    this._chain[loop - 1].setEndLocation(newStartLocation);\n                }\n            }\n        }\n        // ---------- Обратный проход -----------\n        for (var loop = 0; loop < this._chain.length; ++loop) {\n            var thisBone = this._chain[loop];\n            var thisBoneLength = thisBone.getLength();\n            if (loop != 0) {\n                var thisBoneInnerToOuterUV = thisBone.getDirectionUV();\n                var prevBoneInnerToOuterUV = this._chain[loop - 1].getDirectionUV();\n                var thisBoneJoint = thisBone.getJoint();\n                var jointType = thisBoneJoint.getJointType();\n                if (jointType == _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].BALL) {\n                    var angleBetweenDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleBetweenDegs(prevBoneInnerToOuterUV, thisBoneInnerToOuterUV);\n                    var constraintAngleDegs = thisBoneJoint.getBallJointConstraintDegs();\n                    if (angleBetweenDegs > constraintAngleDegs) {\n                        thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleLimitedUnitVectorDegs(thisBoneInnerToOuterUV, prevBoneInnerToOuterUV, constraintAngleDegs);\n                    }\n                }\n                else if (jointType == _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].GLOBAL_HINGE) {\n                    var hingeRotationAxis = thisBoneJoint.getHingeRotationAxis();\n                    thisBoneInnerToOuterUV = thisBoneInnerToOuterUV.projectOntoPlane(hingeRotationAxis);\n                    var cwConstraintDegs = -thisBoneJoint.getHingeClockwiseConstraintDegs();\n                    var acwConstraintDegs = thisBoneJoint.getHingeAnticlockwiseConstraintDegs();\n                    if (!(_utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(cwConstraintDegs, -_FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.001)) &&\n                        !(_utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(acwConstraintDegs, _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.001))) {\n                        var hingeReferenceAxis = thisBoneJoint.getHingeReferenceAxis();\n                        var signedAngleDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getSignedAngleBetweenDegs(hingeReferenceAxis, thisBoneInnerToOuterUV, hingeRotationAxis);\n                        if (signedAngleDegs > acwConstraintDegs) {\n                            thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(hingeReferenceAxis, acwConstraintDegs, hingeRotationAxis).normalised();\n                        }\n                        else if (signedAngleDegs < cwConstraintDegs) {\n                            thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(hingeReferenceAxis, cwConstraintDegs, hingeRotationAxis).normalised();\n                        }\n                    }\n                }\n                else if (jointType == _JointType__WEBPACK_IMPORTED_MODULE_2__[\"JointType\"].LOCAL_HINGE) {\n                    var hingeRotationAxis = thisBoneJoint.getHingeRotationAxis();\n                    var m = _utils_Mat3f__WEBPACK_IMPORTED_MODULE_7__[\"Mat3f\"].createRotationMatrix(prevBoneInnerToOuterUV);\n                    var relativeHingeRotationAxis = m.times(hingeRotationAxis).normalise();\n                    thisBoneInnerToOuterUV = thisBoneInnerToOuterUV.projectOntoPlane(relativeHingeRotationAxis);\n                    var cwConstraintDegs = -thisBoneJoint.getHingeClockwiseConstraintDegs();\n                    var acwConstraintDegs = thisBoneJoint.getHingeAnticlockwiseConstraintDegs();\n                    if (!(_utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(cwConstraintDegs, -_FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.001)) &&\n                        !(_utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(acwConstraintDegs, _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.001))) {\n                        var relativeHingeReferenceAxis = m.times(thisBoneJoint.getHingeReferenceAxis()).normalise();\n                        var signedAngleDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getSignedAngleBetweenDegs(relativeHingeReferenceAxis, thisBoneInnerToOuterUV, relativeHingeRotationAxis);\n                        if (signedAngleDegs > acwConstraintDegs) {\n                            thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(relativeHingeReferenceAxis, acwConstraintDegs, relativeHingeRotationAxis).normalise();\n                        }\n                        else if (signedAngleDegs < cwConstraintDegs) {\n                            thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(relativeHingeReferenceAxis, cwConstraintDegs, relativeHingeRotationAxis).normalise();\n                        }\n                    }\n                }\n                var newEndLocation = thisBone.getStartLocation().plus(thisBoneInnerToOuterUV.times(thisBoneLength));\n                thisBone.setEndLocation(newEndLocation);\n                if (loop < this._chain.length - 1) {\n                    this._chain[loop + 1].setStartLocation(newEndLocation);\n                }\n            }\n            else {\n                if (this._fixedBaseMode) {\n                    thisBone.setStartLocation(this._fixedBaseLocation);\n                }\n                else {\n                    thisBone.setStartLocation(thisBone.getEndLocation().minus(thisBone.getDirectionUV().times(thisBoneLength)));\n                }\n                if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].NONE) {\n                    var newEndLocation = thisBone.getStartLocation().plus(thisBone.getDirectionUV().times(thisBoneLength));\n                    thisBone.setEndLocation(newEndLocation);\n                    if (this._chain.length > 1) {\n                        this._chain[1].setStartLocation(newEndLocation);\n                    }\n                }\n                else {\n                    if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].GLOBAL_ROTOR) {\n                        var thisBoneInnerToOuterUV = thisBone.getDirectionUV();\n                        var angleBetweenDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleBetweenDegs(this._baseboneConstraintUV, thisBoneInnerToOuterUV);\n                        var constraintAngleDegs = thisBone.getBallJointConstraintDegs();\n                        if (angleBetweenDegs > constraintAngleDegs) {\n                            thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleLimitedUnitVectorDegs(thisBoneInnerToOuterUV, this._baseboneConstraintUV, constraintAngleDegs);\n                        }\n                        var newEndLocation = thisBone.getStartLocation().plus(thisBoneInnerToOuterUV.times(thisBoneLength));\n                        thisBone.setEndLocation(newEndLocation);\n                        if (this._chain.length > 1) {\n                            this._chain[1].setStartLocation(newEndLocation);\n                        }\n                    }\n                    else if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].LOCAL_ROTOR) {\n                        var thisBoneInnerToOuterUV = thisBone.getDirectionUV();\n                        var angleBetweenDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleBetweenDegs(this._baseboneRelativeConstraintUV, thisBoneInnerToOuterUV);\n                        var constraintAngleDegs = thisBone.getBallJointConstraintDegs();\n                        if (angleBetweenDegs > constraintAngleDegs) {\n                            thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getAngleLimitedUnitVectorDegs(thisBoneInnerToOuterUV, this._baseboneRelativeConstraintUV, constraintAngleDegs);\n                        }\n                        var newEndLocation = thisBone.getStartLocation().plus(thisBoneInnerToOuterUV.times(thisBoneLength));\n                        thisBone.setEndLocation(newEndLocation);\n                        if (this._chain.length > 1) {\n                            this._chain[1].setStartLocation(newEndLocation);\n                        }\n                    }\n                    else if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].GLOBAL_HINGE) {\n                        var thisJoint = thisBone.getJoint();\n                        var hingeRotationAxis = thisJoint.getHingeRotationAxis();\n                        var cwConstraintDegs = -thisJoint.getHingeClockwiseConstraintDegs();\n                        var acwConstraintDegs = thisJoint.getHingeAnticlockwiseConstraintDegs();\n                        var thisBoneInnerToOuterUV = thisBone.getDirectionUV().projectOntoPlane(hingeRotationAxis);\n                        if (!(_utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(cwConstraintDegs, -_FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.01) &&\n                            _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(acwConstraintDegs, _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.01))) {\n                            var hingeReferenceAxis = thisJoint.getHingeReferenceAxis();\n                            var signedAngleDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getSignedAngleBetweenDegs(hingeReferenceAxis, thisBoneInnerToOuterUV, hingeRotationAxis);\n                            if (signedAngleDegs > acwConstraintDegs) {\n                                thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(hingeReferenceAxis, acwConstraintDegs, hingeRotationAxis).normalise();\n                            }\n                            else if (signedAngleDegs < cwConstraintDegs) {\n                                thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(hingeReferenceAxis, cwConstraintDegs, hingeRotationAxis).normalise();\n                            }\n                        }\n                        var newEndLocation = thisBone.getStartLocation().plus(thisBoneInnerToOuterUV.times(thisBoneLength));\n                        thisBone.setEndLocation(newEndLocation);\n                        if (this._chain.length > 1) {\n                            this._chain[1].setStartLocation(newEndLocation);\n                        }\n                    }\n                    else if (this._baseboneConstraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_4__[\"BaseboneConstraintType3D\"].LOCAL_HINGE) {\n                        var thisJoint = thisBone.getJoint();\n                        var hingeRotationAxis = this._baseboneRelativeConstraintUV;\n                        var cwConstraintDegs = -thisJoint.getHingeClockwiseConstraintDegs();\n                        var acwConstraintDegs = thisJoint.getHingeAnticlockwiseConstraintDegs();\n                        var thisBoneInnerToOuterUV = thisBone.getDirectionUV().projectOntoPlane(hingeRotationAxis);\n                        if (!(_utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(cwConstraintDegs, -_FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.01) &&\n                            _utils_Utils__WEBPACK_IMPORTED_MODULE_5__[\"Utils\"].approximatelyEquals(acwConstraintDegs, _FabrikJoint3D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikJoint3D\"].MAX_CONSTRAINT_ANGLE_DEGS, 0.01))) {\n                            var hingeReferenceAxis = this._baseboneRelativeReferenceConstraintUV;\n                            var signedAngleDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].getSignedAngleBetweenDegs(hingeReferenceAxis, thisBoneInnerToOuterUV, hingeRotationAxis);\n                            if (signedAngleDegs > acwConstraintDegs) {\n                                thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(hingeReferenceAxis, acwConstraintDegs, hingeRotationAxis).normalise();\n                            }\n                            else if (signedAngleDegs < cwConstraintDegs) {\n                                thisBoneInnerToOuterUV = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].rotateAboutAxisDegs(hingeReferenceAxis, cwConstraintDegs, hingeRotationAxis).normalise();\n                            }\n                        }\n                        var newEndLocation = thisBone.getStartLocation().plus(thisBoneInnerToOuterUV.times(thisBoneLength));\n                        thisBone.setEndLocation(newEndLocation);\n                        if (this._chain.length > 1) {\n                            this._chain[1].setStartLocation(newEndLocation);\n                        }\n                    }\n                }\n            }\n        }\n        this._lastTargetLocation.set(target);\n        return _utils_Vec3f__WEBPACK_IMPORTED_MODULE_3__[\"Vec3f\"].distanceBetween(this._chain[this._chain.length - 1].getEndLocation(), target);\n    };\n    FabrikChain3D.prototype.updateChainLength = function () {\n        this._chainLength = 0.0;\n        for (var _i = 0, _a = this._chain; _i < _a.length; _i++) {\n            var aBone = _a[_i];\n            this._chainLength += aBone.getLength();\n        }\n    };\n    FabrikChain3D.prototype.updateEmbeddedTarget = function (newEmbeddedTarget) {\n        if (this._useEmbeddedTarget) {\n            this._embeddedTarget.set(newEmbeddedTarget);\n        }\n        else {\n            throw new Error('This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true).');\n        }\n    };\n    FabrikChain3D.prototype.cloneIkChain = function () {\n        var clonedChain = [];\n        for (var _i = 0, _a = this._chain; _i < _a.length; _i++) {\n            var aBone = _a[_i];\n            var bone = new _FabrikBone3D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikBone3D\"]();\n            bone.set(aBone);\n            clonedChain.push(bone);\n        }\n        return clonedChain;\n    };\n    FabrikChain3D.prototype.getMaxIterationAttempts = function () {\n        return this._maxIterationAttempts;\n    };\n    FabrikChain3D.prototype.getMinIterationChange = function () {\n        return this._minIterationChange;\n    };\n    FabrikChain3D.prototype.getSolveDistanceThreshold = function () {\n        return this._solveDistanceThreshold;\n    };\n    return FabrikChain3D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikChain3D.ts?");

/***/ }),

/***/ "./src/main/FabrikJoint2D.ts":
/*!***********************************!*\
  !*** ./src/main/FabrikJoint2D.ts ***!
  \***********************************/
/*! exports provided: FabrikJoint2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikJoint2D\", function() { return FabrikJoint2D; });\n/* harmony import */ var _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConstraintCoordinateSystem */ \"./src/main/ConstraintCoordinateSystem.ts\");\n\n/**\n * Сустав, определяющий углы-ограничения между костями цепи.\n * <p>\n * FabrikJoint2D состоит из пары углов:\n * <ul><li>Угол-ограничение по часовой стрелке;</li>\n * <li>Угол-ограничение против часовой стрелки.</li></ul>\n * <p>\n * Они оба измеряются в градусах [0..180].\n * Значение по умолчанию для обоих углов - 180, что означает, что сустав не имеет ограничений.\n * Для установки собственных значений углов-ограничений можно воспользоваться конструктором, задать свойствам значения\n * непосредственно по ссылкам {@link #_clockwiseConstraintDegs} и {@link #_anticlockwiseConstraintDegs} или\n * воспользоваться методами-сеттерами {@link #setClockwiseConstraintDegs} and {@link #setAnticlockwiseConstraintDegs}.\n * Первый и третий метод наиболее предпочтительные, так как они осуществляют проверку задаваемых значений.\n * <p>\n * Каждая FabrikBone2D содержит в себе один FabrikJoint2D, который располагается в начале кости {@code mStartLocation}.\n * <p>\n * Сустав отделен от кости в самостоятельный класс в связи с тем, что существует несколько типов ограничений, что\n * делает функциональность сустава громоздкой и сложной для понимания внутри класса кости.\n */\nvar FabrikJoint2D = /** @class */ (function () {\n    // ---------- Constructor ----------\n    /**\n     * Конструктор.\n     * <p>\n     * Принимает три параметра угол-ограничение по часовой стрелке, против часовой стрелки и систему координат.\n     * Все параметры опциональны, в случае отсутствия принимают значения по умолчанию.\n     *\n     * @param clockwiseConstraintDegs\t\tУгол-ограничение по часовой стрелке в градусах.\n     * @param antiClockwiseConstraintDegs\tУгол-ограничение против часовой стрелки в градусах.\n     * @param constraintCoordSystem         Система координат.\n     */\n    function FabrikJoint2D(clockwiseConstraintDegs, antiClockwiseConstraintDegs, constraintCoordSystem) {\n        var _this = this;\n        /**\n         * _clockwiseConstraintDegs\tУгол в градусах, на который данный FabrikJoint2D может быть повернут по часовой стрелке\n         * относительно предыдущей кости или мировой системы координат, в зависимости от выбранной системы координат.\n         * <p>\n         * Допустимые значения [0..180].\n         *\n         * @default 180.0\n         */\n        this._clockwiseConstraintDegs = FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS;\n        /**\n         * mAntiClockwiseContraintDegs\tУгол в градусах, на который данный FabrikJoint2D может быть повернут против часовой стрелки\n         * относительно предыдущей кости или мировой системы координат, в зависимости от выбранной системы координат.\n         * <p>\n         * Допустимые значения [0..180].\n         *\n         * @default 180.0\n         */\n        this._anticlockwiseConstraintDegs = FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS;\n        /**\n         * _constraintCoordinateSystem\tСистема координат, относительно которой задаются углы-ограничения.\n         * <p>\n         * Может принимать значения из перечисления {@link #ConstraintCoordinateSystem}\n         * <p>\n         * Значение по умолчанию - ConstraintCoordinateSystem.LOCAL.\n         */\n        this._constraintCoordinateSystem = _ConstraintCoordinateSystem__WEBPACK_IMPORTED_MODULE_0__[\"ConstraintCoordinateSystem\"].LOCAL;\n        /**\n         * Возвращает угол-ограничение по часовой стрелке в градусах.\n         *\n         * @return\tУгол-ограничение по часовой стрелке в градусах.\n         */\n        this.getClockwiseConstraintDegs = function () { return _this._clockwiseConstraintDegs; };\n        /**\n         * Возвращает угол-ограничение против часовой стрелки в градусах.\n         *\n         * @return\tУгол-ограничение против часовой стрелки в градусах.\n         */\n        this.getAnticlockwiseConstraintDegs = function () { return _this._anticlockwiseConstraintDegs; };\n        /**\n         * Задаёт систему координат данного ограничения.\n         *\n         * @param\tcoordSystem\tСистема координат.\n         */\n        this.setConstraintCoordinateSystem = function (coordSystem) {\n            _this._constraintCoordinateSystem = coordSystem;\n        };\n        /**\n         * Возвращает систему координат данного ограничения.\n         *\n         * @return\tСистема координат.\n         */\n        this.getConstraintCoordinateSystem = function () {\n            return _this._constraintCoordinateSystem;\n        };\n        switch (arguments.length) {\n            case 0:\n                return;\n            case 3:\n                this.setClockwiseConstraintDegs(clockwiseConstraintDegs);\n                this.setAnticlockwiseConstraintDegs(antiClockwiseConstraintDegs);\n                this._constraintCoordinateSystem = constraintCoordSystem;\n                return;\n            default:\n                throw Error('Invalid FabrikJoint2D constructor params!');\n        }\n    }\n    // ---------- Methods ----------\n    /**\n     * Копирует sourceJoint в данный сустав.\n     *\n     * @param sourceJoint   Сустав, значения которого будут скопированы.\n     */\n    FabrikJoint2D.prototype.set = function (sourceJoint) {\n        this.setClockwiseConstraintDegs(sourceJoint._clockwiseConstraintDegs);\n        this.setAnticlockwiseConstraintDegs(sourceJoint._anticlockwiseConstraintDegs);\n        this._constraintCoordinateSystem = sourceJoint._constraintCoordinateSystem;\n    };\n    ;\n    /**\n     * Задаёт угол-ограничение по часовой стрелке в градусах.\n     * <p>\n     * Угол-ограничение может принимать значения от 0 (не предусматривает движения), до 180 (полностью подвижен).\n     * @param\tangleDegs\tУгол-ограничение по часовой стрелке в градусах.\n     */\n    FabrikJoint2D.prototype.setClockwiseConstraintDegs = function (angleDegs) {\n        if (angleDegs < FabrikJoint2D.MIN_2D_CONSTRAINT_ANGLE_DEGS) {\n            this._clockwiseConstraintDegs = FabrikJoint2D.MIN_2D_CONSTRAINT_ANGLE_DEGS;\n        }\n        else if (angleDegs > FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS) {\n            this._clockwiseConstraintDegs = FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS;\n        }\n        else {\n            this._clockwiseConstraintDegs = angleDegs;\n        }\n    };\n    ;\n    /**\n     * Задаёт угол-ограничение против часовой стрелки в градусах.\n     * <p>\n     * Угол-ограничение может принимать значения от 0 (не предусматривает движения), до 180 (полностью подвижен).\n     * @param\tangleDegs\tУгол-ограничение против часовой стрелки в градусах.\n     */\n    FabrikJoint2D.prototype.setAnticlockwiseConstraintDegs = function (angleDegs) {\n        if (angleDegs < FabrikJoint2D.MIN_2D_CONSTRAINT_ANGLE_DEGS) {\n            this._anticlockwiseConstraintDegs = FabrikJoint2D.MIN_2D_CONSTRAINT_ANGLE_DEGS;\n        }\n        else if (angleDegs > FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS) {\n            this._anticlockwiseConstraintDegs = FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS;\n        }\n        else {\n            this._anticlockwiseConstraintDegs = angleDegs;\n        }\n    };\n    ;\n    /** Минимальный угол-ограничение для любого из направлений в градусах. Полностью обездвиживает кость. */\n    FabrikJoint2D.MIN_2D_CONSTRAINT_ANGLE_DEGS = 0;\n    /** Максимальный угол-ограничение для любого из направлений в градусах. Даёт кости полную свободу. */\n    FabrikJoint2D.MAX_2D_CONSTRAINT_ANGLE_DEGS = 180;\n    return FabrikJoint2D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikJoint2D.ts?");

/***/ }),

/***/ "./src/main/FabrikJoint3D.ts":
/*!***********************************!*\
  !*** ./src/main/FabrikJoint3D.ts ***!
  \***********************************/
/*! exports provided: FabrikJoint3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikJoint3D\", function() { return FabrikJoint3D; });\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n/* harmony import */ var _JointType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JointType */ \"./src/main/JointType.ts\");\n/* harmony import */ var _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Vec3f */ \"./src/utils/Vec3f.ts\");\n\n\n\n/**\n * Сустав, определяющий углы-ограничения между костями цепи.\n * <p>\n * Существует три типа суставов:\n * <ul>\n * <li>JointType.BALL - сустав будет вращаться на один и тот же угол во все стороны относительно предыдущей кости\n * в цепи или относительно мировой системы координат, в случае если это начальная кость цепи,</li>\n * <li>JointType.GLOBAL_HINGE - сустав, для которого заданы углы-ограничители относительно мировой системы координат\n * для выбранной оси по и против часовой стрелки,</li>\n * <li>JointType.LOCAL_HINGE - сустав, для которого заданы углы-ограничители относительно предыдущей кости\n * для выбранной оси по и против часовой стрелки.</li>\n * </ul>\n * Шаровой сустав может вращаться в любую сторону относительно положения предыдущей кости в цепи.\n * Угол-ограничитель в 180 градусов будет давать суставу полную свободу движения, а угол в 0\n * градусов не предусматривает движения совсем, делая текущую кость продолжением предыдущей.\n * <p>\n * Шарнирный сустав может вращаться по и против часовой стрелки вдоль каждой оси на допустимое число градусов [0..180].\n * Локальный шарнир ведет отсчет градусов относительно предыдущей кости в цепи,\n * а глобальный - относительно мировой системы координат.\n * <p>\n * Каждая FabrikBone3D имеет один FabrikJoint3D, который располагается в начальной точке кости {@code mStartLocation}.\n *\n */\nvar FabrikJoint3D = /** @class */ (function () {\n    // ---------- Constructors ----------\n    /**\n     * Конструктор.\n     * <p>\n     * Принимает 2 возможных сочетания параметров:\n     * <p>\n     * Без параметров.\n     * Все поля получают занчения по умолчанию.\n     * Задать недефолтные значения можно через методы\n     * {@link #setAsGlobalHinge(Vec3f, number, number, Vec3f)} и\n     * {@link #setAsLocalHinge(Vec3f, number, number, Vec3f)} methods.\n     * <p>\n     * Конструктор копирования.\n     * Создаёт глубокую копию сустава.\n     *\n     * @param source Сустав источник.\n     */\n    function FabrikJoint3D(source) {\n        /**\n         * Угол-ограничение в градусах, на который позволяет повернуться сустав (для шаровых суставов).\n         * <p>\n         * Допустимые значения  [0..180].\n         *\n         * @default 180.0\n         */\n        this._rotorConstraintDegs = FabrikJoint3D.MAX_CONSTRAINT_ANGLE_DEGS;\n        /**\n         * Угол в градусах, на который сустав позволяет повернуться по часовой стрелке\n         * относительно выбранной оси и системы координат (для шарнирных суставов).\n         * <p>\n         * Допустимые значения  [0..180].\n         *\n         * @default 180.0\n         * @see mHingeAxis\n         */\n        this._hingeClockwiseConstraintDegs = FabrikJoint3D.MAX_CONSTRAINT_ANGLE_DEGS;\n        /**\n         * Угол в градусах, на который сустав позволяет повернуться против часовой стрелки\n         * относительно выбранной оси и системы координат (для шарнирных суставов).\n         * <p>\n         * Допустимые значения  [0..180].\n         *\n         * @default 180.0\n         * @see mHingeAxis\n         */\n        this._hingeAnticlockwiseConstraintDegs = FabrikJoint3D.MAX_CONSTRAINT_ANGLE_DEGS;\n        /** Ось вращения шарнирного сустава. */\n        this._rotationAxisUV = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"]();\n        /** Опорная ось шарнирного сустава. */\n        this._referenceAxisUV = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"]();\n        /**\n         * Тип сустава.\n         * <p>\n         * Допустимые значения - JointType.BALL, JointType.GLOBAL_HINGE или JointType.LOCAL_HINGE.\n         *\n         * @default\tJointType.BALL\n         */\n        this._jointType = _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL;\n        if (source)\n            this.set(source);\n    }\n    /**\n     * Делает из данного сустава глубокую копию сустава-источника.\n     *\n     * @param\tsource\tСустав источник.\n     */\n    FabrikJoint3D.prototype.set = function (source) {\n        this._jointType = source._jointType;\n        this._rotorConstraintDegs = source._rotorConstraintDegs;\n        this._hingeClockwiseConstraintDegs = source._hingeClockwiseConstraintDegs;\n        this._hingeAnticlockwiseConstraintDegs = source._hingeAnticlockwiseConstraintDegs;\n        this._rotationAxisUV.set(source._rotationAxisUV);\n        this._referenceAxisUV.set(source._referenceAxisUV);\n    };\n    /**\n     * Задаёт данному суставу шаровой тип.\n     *\n     * @param\tconstraintAngleDegs\tМаксимальный допустимый угол в градусах между костью сустава и предыдущей костью в цепи.\n     */\n    FabrikJoint3D.prototype.setAsBallJoint = function (constraintAngleDegs) {\n        FabrikJoint3D._validateConstraintAngleDegs(constraintAngleDegs);\n        this._rotorConstraintDegs = constraintAngleDegs;\n        this._jointType = _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL;\n    };\n    /**\n     * Задаёт данному суставу шарнирный тип.\n     *\n     * @param jointType\t\t\t\t\t\tТип сустава, допустимы и BALL, и GLOBAL_HINGE, и LOCAL_HINGE.\n     * @param rotationAxis\t\t\t\t\tОсь вращения шарнира.\n     * @param clockwiseConstraintDegs\t\tУгол ограничение по часовой стрелке относительно опорной оси.\n     * @param anticlockwiseConstraintDegs\tУгол ограничение против часовой стрелки относительно опорной оси.\n     * @param referenceAxis\t\t\t\t\tОпорная ось.\n     */\n    FabrikJoint3D.prototype.setHingeJoint = function (jointType, rotationAxis, clockwiseConstraintDegs, anticlockwiseConstraintDegs, referenceAxis) {\n        // Убедимся, что ось вращения и опорная ось образуют плоскость (т. к. они могут быть перпендикулярны и их скалярное произведение равно 0)\n        if (!_utils_Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].approximatelyEquals(_utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].dotProduct(rotationAxis, referenceAxis), 0.0, 0.01)) {\n            var angleDegs = _utils_Vec3f__WEBPACK_IMPORTED_MODULE_2__[\"Vec3f\"].getAngleBetweenDegs(rotationAxis, referenceAxis);\n            throw new Error('The reference axis must be in the plane of the hinge rotation axis - angle between them is currently: ' + angleDegs);\n        }\n        FabrikJoint3D._validateConstraintAngleDegs(clockwiseConstraintDegs);\n        FabrikJoint3D._validateConstraintAngleDegs(anticlockwiseConstraintDegs);\n        FabrikJoint3D._validateAxis(rotationAxis);\n        FabrikJoint3D._validateAxis(referenceAxis);\n        this._hingeClockwiseConstraintDegs = clockwiseConstraintDegs;\n        this._hingeAnticlockwiseConstraintDegs = anticlockwiseConstraintDegs;\n        this._jointType = jointType;\n        this._rotationAxisUV.set(rotationAxis.normalised());\n        this._referenceAxisUV.set(referenceAxis.normalised());\n    };\n    /**\n     * Задаёт угол ограничение по часовой стрелке для шарнирного сустава.\n     * <p>\n     * Вызывает ошибки, если угол выходит за границы допустимых значений и\n     * если тип сустава не шарнирный.\n     *\n     * @param    angleDegs    Угол ограничение по часовой стрелке в градусах.\n     */\n    FabrikJoint3D.prototype.setHingeJointClockwiseConstraintDegs = function (angleDegs) {\n        FabrikJoint3D._validateConstraintAngleDegs(angleDegs);\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            this._hingeClockwiseConstraintDegs = angleDegs;\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have hinge constraint angles.');\n        }\n    };\n    /**\n     * Возвращает угол-ограничение по часовой стрелке для шарнирного сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шарнирный.\n     *\n     * @return Угол-ограничение по часовой стрелке в градусах.\n     */\n    FabrikJoint3D.prototype.getHingeClockwiseConstraintDegs = function () {\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            return this._hingeClockwiseConstraintDegs;\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have hinge constraint angles.');\n        }\n    };\n    /**\n     * Задаёт угол ограничение против часовой стрелки для шарнирного сустава.\n     * <p>\n     * Вызывает ошибки, если угол выходит за границы допустимых значений и\n     * если тип сустава не шарнирный.\n     *\n     * @param    angleDegs    Угол ограничение против часовой стрелки в градусах.\n     */\n    FabrikJoint3D.prototype.setHingeJointAnticlockwiseConstraintDegs = function (angleDegs) {\n        FabrikJoint3D._validateConstraintAngleDegs(angleDegs);\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            this._hingeAnticlockwiseConstraintDegs = angleDegs;\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have hinge constraint angles.');\n        }\n    };\n    /**\n     * Возвращает угол-ограничение против часовой стрелки для шарнирного сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шарнирный.\n     *\n     * @return Угол-ограничение против часовой стрелки в градусах.\n     */\n    FabrikJoint3D.prototype.getHingeAnticlockwiseConstraintDegs = function () {\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            return this._hingeAnticlockwiseConstraintDegs;\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have hinge constraint angles.');\n        }\n    };\n    /**\n     * Задаёт угол-ограничение для шарового сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шаровой или\n     * угол выходит за границы допустимых значений.\n     *\n     * @param\tangleDegs\tУгол-ограничение в градусах.\n     */\n    FabrikJoint3D.prototype.setBallJointConstraintDegs = function (angleDegs) {\n        FabrikJoint3D._validateConstraintAngleDegs(angleDegs);\n        if (this._jointType === _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            this._rotorConstraintDegs = angleDegs;\n        }\n        else {\n            throw new Error('This joint is of type: ' + this._jointType + ' - only joints of type JointType.BALL have a ball joint constraint angle.');\n        }\n    };\n    /**\n     * Возвращает угол ограничение шарового сустава.\n     * <p>\n     * Вызывает ошибку, если тип сустава не шаровой\n     *\n     * @return\tУгол-ограничение в градусах.\n     */\n    FabrikJoint3D.prototype.getBallJointConstraintDegs = function () {\n        if (this._jointType === _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            return this._rotorConstraintDegs;\n        }\n        else {\n            throw new Error('This joint is not of type JointType.BALL - it does not have a ball joint constraint angle.');\n        }\n    };\n    /**\n     * Задаёт ось вращения шарнирного сустава как нормализованную версию исходной оси.\n     * <p>\n     * Вызывает ошибки, если переданная ось имеет нулевую длину и если тип сустава не шарнирный.\n     *\n     * @param axis\tОсь вращения.\n     */\n    FabrikJoint3D.prototype.setHingeRotationAxis = function (axis) {\n        FabrikJoint3D._validateAxis(axis);\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            this._rotationAxisUV.set(axis.normalised());\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have a hinge rotation axis.');\n        }\n    };\n    /**\n     * Возвращает опорную ось шарнирного сустава.\n     * <p>\n     * Если тип сустава не шарнирный, выбрасывается ошибка.\n     *\n     * @return\tОпорная ось.\n     */\n    FabrikJoint3D.prototype.getHingeReferenceAxis = function () {\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            return this._referenceAxisUV;\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have a hinge reference axis.');\n        }\n    };\n    /**\n     * Задаёт опорную ось шарнирного сустава, относительно которой измеряется угол вращения сустава.\n     * <p>\n     * Вызывает ошибки, если переданная ось имеет нулевую длину и если тип сустава не шарнирный.\n     *\n     * @param referenceAxis\tОпорная ось.\n     */\n    FabrikJoint3D.prototype.setHingeReferenceAxis = function (referenceAxis) {\n        FabrikJoint3D._validateAxis(referenceAxis);\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            this._referenceAxisUV.set(referenceAxis.normalised());\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have a hinge reference axis.');\n        }\n    };\n    /**\n     * Возвращает ось вращения шарнирного сустава.\n     * <p>\n     * Если у сустава тип JointType.BALL (т.е. он не шарнирный) бросам ошибку.\n     *\n     * @return\tОсь вращения шарнирного сустава.\n     */\n    FabrikJoint3D.prototype.getHingeRotationAxis = function () {\n        if (this._jointType !== _JointType__WEBPACK_IMPORTED_MODULE_1__[\"JointType\"].BALL) {\n            return this._rotationAxisUV;\n        }\n        else {\n            throw new Error('Joint type is JointType.BALL - it does not have a hinge rotation axis.');\n        }\n    };\n    /**\n     * Возвращает тип сустава.\n     * <p>\n     * Допустимые значения: JointType.BALL, JointType.GLOBAL_HINGE, JointType.LOCAL_HINGE.\n     *\n     * @return\tТип сустава.\n     */\n    FabrikJoint3D.prototype.getJointType = function () { return this._jointType; };\n    // ---------- Private Methods ----------\n    FabrikJoint3D._validateConstraintAngleDegs = function (angleDegs) {\n        if (angleDegs < FabrikJoint3D.MIN_CONSTRAINT_ANGLE_DEGS || angleDegs > FabrikJoint3D.MAX_CONSTRAINT_ANGLE_DEGS) {\n            throw new Error('Constraint angles must be within the range ' + FabrikJoint3D.MIN_CONSTRAINT_ANGLE_DEGS + ' to ' + FabrikJoint3D.MAX_CONSTRAINT_ANGLE_DEGS + ' inclusive.');\n        }\n    };\n    FabrikJoint3D._validateAxis = function (axis) {\n        if (axis.length() <= 0.0) {\n            throw new Error('Provided axis is illegal - it has a magnitude of zero.');\n        }\n    };\n    /** Минимальный угол-ограничение для любого из направлений в градусах. Полностью обездвиживает кость. */\n    FabrikJoint3D.MIN_CONSTRAINT_ANGLE_DEGS = 0.0;\n    /** Максимальный угол-ограничение для любого из направлений в градусах. Даёт кости полную свободу. */\n    FabrikJoint3D.MAX_CONSTRAINT_ANGLE_DEGS = 180.0;\n    return FabrikJoint3D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikJoint3D.ts?");

/***/ }),

/***/ "./src/main/FabrikStructure2D.ts":
/*!***************************************!*\
  !*** ./src/main/FabrikStructure2D.ts ***!
  \***************************************/
/*! exports provided: FabrikStructure2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikStructure2D\", function() { return FabrikStructure2D; });\n/* harmony import */ var _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Vec2f */ \"./src/utils/Vec2f.ts\");\n/* harmony import */ var _FabrikChain2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FabrikChain2D */ \"./src/main/FabrikChain2D.ts\");\n/* harmony import */ var _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BoneConnectionPoint */ \"./src/main/BoneConnectionPoint.ts\");\n/* harmony import */ var _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseboneConstraintType2D */ \"./src/main/BaseboneConstraintType2D.ts\");\n\n\n\n\n/**\n * Набор 2D цепей.\n **/\nvar FabrikStructure2D = /** @class */ (function () {\n    // --------- Public Methods ----------\n    /** Конструктор.\n     * Принимает два варианта значений:\n     * Конструктор без параметров - задает всем полям значения по умолчанию.\n     *\n     * Один параметр. Задает имя структуры.\n     *\n     * @param name Имя структуры.\n     * */\n    function FabrikStructure2D(name) {\n        if (name === void 0) { name = ''; }\n        // ---------- Private Properties ----------\n        /** Название структуры. */\n        this._name = '';\n        /** Список цепей. */\n        this._chains = [];\n        this._name = name;\n    }\n    FabrikStructure2D.prototype.setName = function (name) { this._name = name; };\n    /**\n     * Решает задачу ИК для всех цепей структуры.\n     * <p>\n     * Все цепи перемещаются к единой целевой позиции за исключением тех, для которых задан embeddedTargetMode.\n     *\n     * @param   newTargetLocation    Целевая позиция для всех эффекторов структуры.\n     */\n    FabrikStructure2D.prototype.solveForTarget = function (newTargetLocation) {\n        var nu_chains = this._chains.length;\n        var hostChainNumber;\n        var thisChain;\n        for (var loop = 0; loop < nu_chains; ++loop) {\n            thisChain = this._chains[loop];\n            hostChainNumber = thisChain.getConnectedChainNumber();\n            var constraintType = thisChain.getBaseboneConstraintType();\n            if (hostChainNumber !== -1 && constraintType !== _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_3__[\"BaseboneConstraintType2D\"].GLOBAL_ABSOLUTE) {\n                var hostBone = this._chains[hostChainNumber].getBone(this._chains[loop].getConnectedBoneNumber());\n                if (thisChain.getBoneConnectionPoint() == _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_2__[\"BoneConnectionPoint\"].START) {\n                    thisChain.setBaseLocation(hostBone.getStartLocation());\n                }\n                else {\n                    thisChain.setBaseLocation(hostBone.getEndLocation());\n                }\n                var hostBoneUV = hostBone.getDirectionUV();\n                if (constraintType == _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_3__[\"BaseboneConstraintType2D\"].LOCAL_RELATIVE) {\n                    this._chains[loop].setBaseboneConstraintUV(hostBoneUV);\n                }\n                else if (constraintType == _BaseboneConstraintType2D__WEBPACK_IMPORTED_MODULE_3__[\"BaseboneConstraintType2D\"].LOCAL_ABSOLUTE) {\n                    var angleDegs = FabrikStructure2D.UP.getSignedAngleDegsTo(hostBoneUV);\n                    var relativeConstraintUV = _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"].rotateDegs(thisChain.getBaseboneConstraintUV(), angleDegs);\n                    thisChain.setBaseboneRelativeConstraintUV(relativeConstraintUV);\n                }\n            }\n            if (!thisChain.getEmbeddedTargetMode()) {\n                thisChain.solveForTarget(newTargetLocation);\n            }\n            else {\n                thisChain.solveForEmbeddedTarget();\n            }\n        }\n    };\n    FabrikStructure2D.prototype.addChain = function (chain) {\n        this._chains.push(chain);\n    };\n    FabrikStructure2D.prototype.connectChain = function (chain, chainNumber, boneNumber, boneConnectionPoint, shouldCalcCoordinates) {\n        chain.setBoneConnectionPoint(boneConnectionPoint);\n        if (chainNumber >= this._chains.length) {\n            throw new Error('Cannot connect to chain ' + chainNumber + ' - no such chain (remember that chains are zero indexed).');\n        }\n        if (boneNumber >= this._chains[chainNumber].getNumBones()) {\n            throw new Error('Cannot connect to bone ' + boneNumber + ' of chain ' + chainNumber + ' - no such bone (remember that bones are zero indexed).');\n        }\n        var relativeChain = new _FabrikChain2D__WEBPACK_IMPORTED_MODULE_1__[\"FabrikChain2D\"](chain);\n        relativeChain.setConnectedChainNumber(chainNumber);\n        relativeChain.setConnectedBoneNumber(boneNumber);\n        var connectionPoint = chain.getBoneConnectionPoint();\n        var connectionLocation;\n        if (connectionPoint == _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_2__[\"BoneConnectionPoint\"].START) {\n            connectionLocation = this._chains[chainNumber].getBone(boneNumber).getStartLocation();\n        }\n        else {\n            connectionLocation = this._chains[chainNumber].getBone(boneNumber).getEndLocation();\n        }\n        relativeChain.setBaseLocation(connectionLocation);\n        relativeChain.setFixedBaseMode(true);\n        if (shouldCalcCoordinates) {\n            for (var loop = 0; loop < chain.getNumBones(); ++loop) {\n                var origStart = relativeChain.getBone(loop).getStartLocation();\n                var origEnd = relativeChain.getBone(loop).getEndLocation();\n                var translatedStart = origStart.plus(connectionLocation);\n                var translatedEnd = origEnd.plus(connectionLocation);\n                relativeChain.getBone(loop).setStartLocation(translatedStart);\n                relativeChain.getBone(loop).setEndLocation(translatedEnd);\n            }\n        }\n        this.addChain(relativeChain);\n    };\n    FabrikStructure2D.prototype.getNumChains = function () { return this._chains.length; };\n    FabrikStructure2D.prototype.getChain = function (chainNumber) { return this._chains[chainNumber]; };\n    FabrikStructure2D.prototype.getName = function () {\n        return this._name;\n    };\n    FabrikStructure2D.UP = new _utils_Vec2f__WEBPACK_IMPORTED_MODULE_0__[\"Vec2f\"](0.0, 1.0);\n    return FabrikStructure2D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikStructure2D.ts?");

/***/ }),

/***/ "./src/main/FabrikStructure3D.ts":
/*!***************************************!*\
  !*** ./src/main/FabrikStructure3D.ts ***!
  \***************************************/
/*! exports provided: FabrikStructure3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FabrikStructure3D\", function() { return FabrikStructure3D; });\n/* harmony import */ var _FabrikChain3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FabrikChain3D */ \"./src/main/FabrikChain3D.ts\");\n/* harmony import */ var _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BoneConnectionPoint */ \"./src/main/BoneConnectionPoint.ts\");\n/* harmony import */ var _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseboneConstraintType3D */ \"./src/main/BaseboneConstraintType3D.ts\");\n/* harmony import */ var _utils_Mat3f__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Mat3f */ \"./src/utils/Mat3f.ts\");\n\n\n\n\n/**\n * Набор 3D цепей.\n **/\nvar FabrikStructure3D = /** @class */ (function () {\n    // --------- Public Methods ----------\n    /**\n     * Конструктор.\n     * Принимает два варианта значений:\n     *\n     * Конструктор без параметров - задает всем полям значения по умолчанию.\n     *\n     * Один параметр. Задает имя структуры.\n     * @param name Имя структуры.\n     * */\n    function FabrikStructure3D(name) {\n        if (name === void 0) { name = ''; }\n        // ---------- Private Properties ----------\n        /** Название структуры. */\n        this._name = '';\n        /** Список цепей. */\n        this._chains = [];\n        this._name = name;\n    }\n    /**\n     * Решает задачу ИК для всех цепей структуры.\n     * <p>\n     * Все цепи перемещаются к единой целевой позиции за исключением тех, для которых задан embeddedTargetMode.\n     *\n     * @param   newTargetLocation    Целевая позиция для всех эффекторов структуры.\n     */\n    FabrikStructure3D.prototype.solveForTarget = function (newTargetLocation) {\n        var nu_chains = this._chains.length;\n        var connectedChainNumber;\n        for (var loop = 0; loop < nu_chains; ++loop) {\n            var thisChain = this._chains[loop];\n            connectedChainNumber = thisChain.getConnectedChainNumber();\n            if (connectedChainNumber === -1) {\n                if (!thisChain.getEmbeddedTargetMode()) {\n                    thisChain.solveForTarget(newTargetLocation);\n                }\n                else {\n                    thisChain.solveForEmbeddedTarget();\n                }\n            }\n            else {\n                var hostChain = this._chains[connectedChainNumber];\n                var hostBone = hostChain.getBone(thisChain.getConnectedBoneNumber());\n                if (hostBone.getBoneConnectionPoint() == _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_1__[\"BoneConnectionPoint\"].START) {\n                    thisChain.setBaseLocation(hostBone.getStartLocation());\n                }\n                else {\n                    thisChain.setBaseLocation(hostBone.getEndLocation());\n                }\n                var constraintType = thisChain.getBaseboneConstraintType();\n                switch (constraintType) {\n                    case _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__[\"BaseboneConstraintType3D\"].NONE:\n                    case _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__[\"BaseboneConstraintType3D\"].GLOBAL_ROTOR:\n                    case _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__[\"BaseboneConstraintType3D\"].GLOBAL_HINGE:\n                        break;\n                    case _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__[\"BaseboneConstraintType3D\"].LOCAL_ROTOR:\n                    case _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__[\"BaseboneConstraintType3D\"].LOCAL_HINGE: {\n                        var connectionBoneMatrix = _utils_Mat3f__WEBPACK_IMPORTED_MODULE_3__[\"Mat3f\"].createRotationMatrix(hostBone.getDirectionUV());\n                        var relativeBaseboneConstraintUV = connectionBoneMatrix.times(thisChain.getBaseboneConstraintUV()).normalised();\n                        thisChain._setBaseboneRelativeConstraintUV(relativeBaseboneConstraintUV);\n                        if (constraintType == _BaseboneConstraintType3D__WEBPACK_IMPORTED_MODULE_2__[\"BaseboneConstraintType3D\"].LOCAL_HINGE) {\n                            thisChain._setBaseboneRelativeReferenceConstraintUV(connectionBoneMatrix.times(thisChain.getBone(0).getJoint().getHingeReferenceAxis()));\n                        }\n                        break;\n                    }\n                }\n                if (!thisChain.getEmbeddedTargetMode()) {\n                    thisChain.solveForTarget(newTargetLocation);\n                }\n                else {\n                    thisChain.solveForEmbeddedTarget();\n                }\n            }\n        }\n    };\n    FabrikStructure3D.prototype.addChain = function (chain) {\n        this._chains.push(chain);\n    };\n    FabrikStructure3D.prototype.removeChain = function (chainIndex) {\n        this._chains.splice(chainIndex, 1);\n    };\n    FabrikStructure3D.prototype.connectChain = function (newChain, existingChainNumber, existingBoneNumber, boneConnectionPoint, shouldCalcCoordinates) {\n        if (existingChainNumber > this._chains.length) {\n            throw new Error('Cannot connect to chain ' + existingChainNumber + ' - no such chain (remember that chains are zero indexed).');\n        }\n        if (existingBoneNumber > this._chains[existingChainNumber].getNumBones()) {\n            throw new Error('Cannot connect to bone ' + existingBoneNumber + ' of chain ' + existingChainNumber + ' - no such bone (remember that bones are zero indexed).');\n        }\n        var relativeChain = new _FabrikChain3D__WEBPACK_IMPORTED_MODULE_0__[\"FabrikChain3D\"](newChain);\n        relativeChain.connectToStructure(this, existingChainNumber, existingBoneNumber);\n        this.getChain(existingChainNumber).getBone(existingBoneNumber).setBoneConnectionPoint(boneConnectionPoint);\n        var connectionLocation;\n        if (boneConnectionPoint == _BoneConnectionPoint__WEBPACK_IMPORTED_MODULE_1__[\"BoneConnectionPoint\"].START) {\n            connectionLocation = this._chains[existingChainNumber].getBone(existingBoneNumber).getStartLocation();\n        }\n        else {\n            connectionLocation = this._chains[existingChainNumber].getBone(existingBoneNumber).getEndLocation();\n        }\n        relativeChain.setBaseLocation(connectionLocation);\n        relativeChain.setFixedBaseMode(true);\n        if (shouldCalcCoordinates) {\n            for (var loop = 0; loop < relativeChain.getNumBones(); ++loop) {\n                var origStart = relativeChain.getBone(loop).getStartLocation();\n                var origEnd = relativeChain.getBone(loop).getEndLocation();\n                var translatedStart = origStart.plus(connectionLocation);\n                var translatedEnd = origEnd.plus(connectionLocation);\n                relativeChain.getBone(loop).setStartLocation(translatedStart);\n                relativeChain.getBone(loop).setEndLocation(translatedEnd);\n            }\n        }\n        this.addChain(relativeChain);\n    };\n    FabrikStructure3D.prototype.getNumChains = function () {\n        return this._chains.length;\n    };\n    FabrikStructure3D.prototype.getChain = function (chainNumber) {\n        return this._chains[chainNumber];\n    };\n    /**\n     * Задаёт имя структуре.\n     *\n     * @param    name    Желаемое имя.\n     */\n    FabrikStructure3D.prototype.setName = function (name) {\n        this._name = name;\n    };\n    /**\n     * Возвращает имя структуры.\n     *\n     * @return\n     */\n    FabrikStructure3D.prototype.getName = function () {\n        return this._name;\n    };\n    return FabrikStructure3D;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/main/FabrikStructure3D.ts?");

/***/ }),

/***/ "./src/main/JointType.ts":
/*!*******************************!*\
  !*** ./src/main/JointType.ts ***!
  \*******************************/
/*! exports provided: JointType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JointType\", function() { return JointType; });\n/**\n * Тип сустава.\n *\n * <ul><li><strong>JointType.BALL</strong> - тип сустава, имеющий один угол-ограничение,\n * на который он может поворачиваться во всех направлениях. Если угол-ограничитель равен 180 -\n * сустав может быть повернут куда угодно, в противном случае, если угол-ограничитель равен 0 -\n * сустав не может двигаться вовсе.</li>\n * <li><strong>JointType.GLOBAL_HINGE</strong> - тип сустава, при котором ограничения задаются\n * на вращение в определенном направлении, относительно мировой системы координат. По выбранной оси\n * задаётся 2 значения - по и против часовой стрелки - на которые сустав позволяет поворачиваться.\n * Все значения указываются в пределах от 0 до 180 градусов.</li>\n * <li><strong>JointType.LOCAL_HINGE</strong> - тип сустава, при котором ограничения задаются\n * а вращение в определенном направлении, относительно предыдущей кости. По выбранной оси\n * задаётся 2 значения - по и против часовой стрелки - на которые сустав позволяет поворачиваться.\n * Все значения указываются в пределах от 0 до 180 градусов.</li>\n * </ul>\n */\nvar JointType;\n(function (JointType) {\n    JointType[JointType[\"BALL\"] = 0] = \"BALL\";\n    JointType[JointType[\"GLOBAL_HINGE\"] = 1] = \"GLOBAL_HINGE\";\n    JointType[JointType[\"LOCAL_HINGE\"] = 2] = \"LOCAL_HINGE\";\n})(JointType || (JointType = {}));\n\n\n//# sourceURL=webpack://MovikJS/./src/main/JointType.ts?");

/***/ }),

/***/ "./src/utils/Colour4f.ts":
/*!*******************************!*\
  !*** ./src/utils/Colour4f.ts ***!
  \*******************************/
/*! exports provided: Colour4f */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Colour4f\", function() { return Colour4f; });\n/**\n * Цвет в формате RGBA.\n * <p>\n * Представлен четырьмя r, g, b, a свойствами типа Number.\n * Задать значения данных свойств можно присваиванием напрямую, через конструктор или\n * через функции сеттеры.\n * Допустимые значения для каждой переменной - число [0..1].\n * Использование значений вне этого диапазона может привести к неопределенному поведению.\n */\nvar Colour4f = /** @class */ (function () {\n    // ---------- Constructor ----------\n    /**\n     * Конструктор.\n     * <p>\n     * Принимает один из двух возможных сочетаний параметров:<ul>\n     * <li>\n     *     Без параметров - проставляет значения по умолчанию всем полям.\n     * </li>\n     * <li>\n     *     Принимает массив из 4 значений для компонент по порядку: [red, green, blue, alpha].\n     *\n     *     @param source {number[]} Значения компонент цвета.\n     * </li>\n     * </ul>\n     *\n     * Все значения должны быть в пределах [0..1].\n     */\n    function Colour4f(source) {\n        var _this = this;\n        /** Red компонента. */\n        this.r = 1;\n        /** Green компонента. */\n        this.g = 1;\n        /** Blue компонента. */\n        this.b = 1;\n        /** Alpha компонента (компонента непрозрачности).\n         *  */\n        this.a = 1;\n        /**\n         * Возвращает массив компонент данного цвета в порядке RGBA.\n         *\n         * @return\tДанный цвет в виде числового массива.\n         */\n        this.toArray = function () { return [_this.r, _this.g, _this.b, _this.a]; };\n        switch (arguments.length) {\n            case 0:\n                break;\n            case 1:\n                if (source instanceof Array && source.length == 4) {\n                    this.r = Colour4f._clamp(source[0]);\n                    this.g = Colour4f._clamp(source[1]);\n                    this.b = Colour4f._clamp(source[2]);\n                    this.a = Colour4f._clamp(source[3]);\n                }\n                else {\n                    throw new Error('Colour source array size must be precisely 4 elements.');\n                }\n                break;\n            default:\n                throw new Error('Colour constructor was invoked incorrectly.');\n        }\n    }\n    // ---------- Public Methods ----------\n    /**\n     * Задёт значения компонент.\n     * <p>\n     * Если значения не подходят по диапазону, то они заменяются на граничные.\n     *\n     * @param   source \tМассив из 4 значений для компонент по порядку: [red, green, blue, alpha].\n     */\n    Colour4f.prototype.set = function (source) {\n        this.r = Colour4f._clamp(source[0]);\n        this.g = Colour4f._clamp(source[1]);\n        this.b = Colour4f._clamp(source[2]);\n        this.a = Colour4f._clamp(source[3]);\n    };\n    ;\n    /**\n     * Добавляет заданные значения к RGB компонентам и возвращает изменненный цвет для формирования цепочки.\n     * <p>\n     * Если при добавленни значений происходит выход за границы диапазона,\n     * то результат заменяется на ближайшее граничное.\n     *\n     * @param   red\t\tRed компонента для добавления.\n     * @param   green\tGreen компонента для добавления.\n     * @param   blue\tBlue компонента для добавления.\n     * @return\t\t\tThis модифицированный цвет.\n     */\n    Colour4f.prototype.addRGB = function (red, green, blue) {\n        this.r = Colour4f._clamp(this.r + red);\n        this.g = Colour4f._clamp(this.g + green);\n        this.b = Colour4f._clamp(this.b + blue);\n        return this;\n    };\n    ;\n    /**\n     * Вычитает заданные значения из RGB компонент и возвращает изменненный цвет для формирования цепочки.\n     * <p>\n     * Если при вычитании значений происходит выход за границы диапазона,\n     * то результат заменяется на ближайшее граничное.\n     *\n     * @param   red\t\tRed компонента для вычитания.\n     * @param   green\tGreen компонента для вычитания.\n     * @param   blue\tBlue компонента для вычитания.\n     * @return\t\t\tThis модифицированный цвет.\n     */\n    Colour4f.prototype.subtractRGB = function (red, green, blue) {\n        this.r = Colour4f._clamp(this.r - red);\n        this.g = Colour4f._clamp(this.g - green);\n        this.b = Colour4f._clamp(this.b - blue);\n        return this;\n    };\n    ;\n    /**\n     * Осветляет RGB компоненты данного цвета на заданное количество единиц.\n     * <p>\n     * Результирующий цвет приводится к диапазону [0..1] и возвращается для создания цепочки.\n     *\n     * @param\tamount\tЗначение, которое необходимо прибавить к RGB компонентам текущего цвета.\n     * @return\t\t\tТекущий цвет после модицикации.\n     */\n    Colour4f.prototype.lighten = function (amount) {\n        return this.addRGB(amount, amount, amount);\n    };\n    /**\n     * Затемняет RGB компоненты данного цвета на заданное количество единиц.\n     * <p>\n     * Результирующий цвет приводится к диапазону [0..1] и возвращается для создания цепочки.\n     *\n     * @param\tamount\tЗначение, которое необходимо отнять от RGB компонент текущего цвета.\n     * @return\t\t\tТекущий цвет после модицикации.\n     */\n    Colour4f.prototype.darken = function (amount) {\n        return this.subtractRGB(amount, amount, amount);\n    };\n    // ---------- Private Methods ----------\n    Colour4f._clamp = function (componentValue) {\n        if (componentValue > Colour4f.MAX_COMPONENT_VALUE) {\n            return Colour4f.MAX_COMPONENT_VALUE;\n        }\n        else if (componentValue < Colour4f.MIN_COMPONENT_VALUE) {\n            return Colour4f.MIN_COMPONENT_VALUE;\n        }\n        else {\n            return componentValue;\n        }\n    };\n    // ---------- Properties ----------\n    /** Минимально допустимое значение для компоненты цвета. */\n    Colour4f.MIN_COMPONENT_VALUE = 0;\n    /** Максимально допустимое значение для компоненты цвета. */\n    Colour4f.MAX_COMPONENT_VALUE = 1;\n    return Colour4f;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/utils/Colour4f.ts?");

/***/ }),

/***/ "./src/utils/Mat3f.ts":
/*!****************************!*\
  !*** ./src/utils/Mat3f.ts ***!
  \****************************/
/*! exports provided: Mat3f */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mat3f\", function() { return Mat3f; });\n/* harmony import */ var _Vec3f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3f */ \"./src/utils/Vec3f.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./src/utils/Utils.ts\");\n\n\n/**\n * Числовая матрица 3x3.\n * <p>\n * Элементы данной матрицы:\n * m00  m10  m20\n * m01\tm11  m21\n * m02\tm12  m22\n * <p>\n * Основной элемент матрицы - столбец.\n *\n */\nvar Mat3f = /** @class */ (function () {\n    /**\n     * Конструктор.\n     * Принимает 9 параметров или ноль.\n     *\n     * @param\tm00\tПервый компонент по оси X.\n     * @param\tm01\tВторой компонент по оси X.\n     * @param\tm02\tТретий компонент по оси X.\n     * @param\tm10\tПервый компонент по оси Y.\n     * @param\tm11\tВторой компонент по оси Y.\n     * @param\tm12\tТретий компонент по оси Y.\n     * @param\tm20\tПервый компонент по оси Z.\n     * @param\tm21\tВторой компонент по оси Z.\n     * @param\tm22\tТретий компонент по оси Z.\n     */\n    function Mat3f(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        var _this = this;\n        // Первый вектор-столбец - положительно направление оси X.\n        this.m00 = 0;\n        this.m01 = 0;\n        this.m02 = 0;\n        // Второй вектор-столбец - положительно направление оси Y.\n        this.m10 = 0;\n        this.m11 = 0;\n        this.m12 = 0;\n        // Третий вектор-столбец - положительно направление оси Z.\n        this.m20 = 0;\n        this.m21 = 0;\n        this.m22 = 0;\n        /**\n         * Поворачивает эту матрицу на угол-параметр относительно оси-параметра.\n         * Не модифицирует исходную матрицу.\n         *\n         *  @param\tangleDegs\tУгол в градусах.\n         *  @param\tlocalAxis\tОсь.\n         *  @return\n         *  */\n        this.rotateDegs = function (angleDegs, localAxis) { return _this.rotateRads(localAxis, angleDegs * _Utils__WEBPACK_IMPORTED_MODULE_1__[\"Utils\"].DEGS_TO_RADS); };\n        /**\n         * Возвращает значения матрицы по оси X.\n         *\n         * @return\n         **/\n        this.getXBasis = function () { return new _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](_this.m00, _this.m01, _this.m02); };\n        /**\n         * Возвращает значения матрицы по оси Y.\n         *\n         * @return\n         **/\n        this.getYBasis = function () { return new _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](_this.m10, _this.m11, _this.m12); };\n        /**\n         * Возвращает значения матрицы по оси Z.\n         *\n         * @return\n         **/\n        this.getZBasis = function () { return new _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](_this.m20, _this.m21, _this.m22); };\n        /**\n         * Возвращает матрицу в виде массива из девяти чисел.\n         *\n         * @return\tМатрица как массив из 9 чисел.\n         */\n        this.toArray = function () { return [_this.m00, _this.m01, _this.m02, _this.m10, _this.m11, _this.m12, _this.m20, _this.m21, _this.m22]; };\n        switch (arguments.length) {\n            case 0:\n                return;\n            case 9:\n                this.m00 = m00;\n                this.m01 = m01;\n                this.m02 = m02;\n                this.m10 = m10;\n                this.m11 = m11;\n                this.m12 = m12;\n                this.m20 = m20;\n                this.m21 = m21;\n                this.m22 = m22;\n                return;\n            default:\n                throw Error('Invalid Mat3f constructor params.');\n        }\n    }\n    /** Зануляет все числа в матрице. */\n    Mat3f.prototype.zero = function () { this.m00 = this.m01 = this.m02 = this.m10 = this.m11 = this.m12 = this.m20 = this.m21 = this.m22 = 0.0; };\n    /** Превращает данную матрицу в единичную. */\n    Mat3f.prototype.setIdentity = function () {\n        this.m00 = this.m11 = this.m22 = 1.0;\n        this.m01 = this.m02 = this.m10 = this.m12 = this.m20 = this.m21 = 0.0;\n    };\n    /**\n     * Задаёт матрицу вращения.\n     *\n     * @param\treferenceDirection\tВектор используемый в качестве оси Z.\n     * @return\tМатрица вращения.\n     */\n    Mat3f.createRotationMatrix = function (referenceDirection) {\n        var rotMat = new Mat3f();\n        if (referenceDirection.y == 1.0) {\n            referenceDirection.y -= 0.0001;\n            referenceDirection.normalise();\n        }\n        rotMat.setZBasis(referenceDirection);\n        rotMat.setXBasis(_Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"].crossProduct(referenceDirection, new _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](0.0, 1.0, 0.0)).normalised());\n        rotMat.setYBasis(_Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"].crossProduct(rotMat.getXBasis(), rotMat.getZBasis()).normalised());\n        return rotMat;\n    };\n    /**\n     * Состоит ли матрица из трёх ортогональных векторов.\n     *\n     * @return\tОртогональна ли матрица.\n     */\n    Mat3f.prototype.isOrthogonal = function () {\n        var xCrossYDot = _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"].dotProduct(this.getXBasis(), this.getYBasis());\n        var xCrossZDot = _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"].dotProduct(this.getXBasis(), this.getZBasis());\n        var yCrossZDot = _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"].dotProduct(this.getYBasis(), this.getZBasis());\n        return (_Utils__WEBPACK_IMPORTED_MODULE_1__[\"Utils\"].approximatelyEquals(xCrossYDot, 0.0, 0.01) &&\n            _Utils__WEBPACK_IMPORTED_MODULE_1__[\"Utils\"].approximatelyEquals(xCrossZDot, 0.0, 0.01) &&\n            _Utils__WEBPACK_IMPORTED_MODULE_1__[\"Utils\"].approximatelyEquals(yCrossZDot, 0.0, 0.01));\n    };\n    /**\n     * Умножает матрицу на вектор обычным матричным умножением.\n     *\n     * @param\tsource\tВектор.\n     * @return\n     */\n    Mat3f.prototype.times = function (source) {\n        return new _Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](this.m00 * source.x + this.m10 * source.y + this.m20 * source.z, this.m01 * source.x + this.m11 * source.y + this.m21 * source.z, this.m02 * source.x + this.m12 * source.y + this.m22 * source.z);\n    };\n    /**\n     * Вычисляет определитель матрицы.\n     *\n     * @return\tОпределитель матрицы.\n     */\n    Mat3f.prototype.determinant = function () {\n        return this.m20 * this.m01 * this.m12\n            - this.m20 * this.m02 * this.m11\n            - this.m10 * this.m01 * this.m22\n            + this.m10 * this.m02 * this.m21\n            + this.m00 * this.m11 * this.m22\n            - this.m00 * this.m12 * this.m21;\n    };\n    /**\n     * Возвращает обратную матрицу для матрицы-параметра.\n     *\n     * @param\tm\tИсходная матрица.\n     * @return\t\tМатрица обратная исходной.\n     */\n    Mat3f.inverse = function (m) {\n        var d = m.determinant();\n        var temp = new Mat3f();\n        temp.m00 = (m.m11 * m.m22 - m.m12 * m.m21) / d;\n        temp.m01 = -(m.m01 * m.m22 - m.m02 * m.m21) / d;\n        temp.m02 = (m.m01 * m.m12 - m.m02 * m.m11) / d;\n        temp.m10 = -(-m.m20 * m.m12 + m.m10 * m.m22) / d;\n        temp.m11 = (-m.m20 * m.m02 + m.m00 * m.m22) / d;\n        temp.m12 = -(-m.m10 * m.m02 + m.m00 * m.m12) / d;\n        temp.m20 = (-m.m20 * m.m11 + m.m10 * m.m21) / d;\n        temp.m21 = -(-m.m20 * m.m01 + m.m00 * m.m21) / d;\n        temp.m22 = (-m.m10 * m.m02 + m.m00 * m.m11) / d;\n        return temp;\n    };\n    /**\n     * Поворачивает эту матрицу на угол-параметр относительно оси-параметра.\n     * Не модифицирует исходную матрицу.\n     *\n     *  @param\tangleRads\tУгол в радианах.\n     *  @param\trotationAxis\tОсь.\n     *  @return\n     *  */\n    Mat3f.prototype.rotateRads = function (rotationAxis, angleRads) {\n        var dest = new Mat3f();\n        var sin = Math.sin(angleRads);\n        var cos = Math.cos(angleRads);\n        var oneMinusCos = 1.0 - cos;\n        var xy = rotationAxis.x * rotationAxis.y;\n        var yz = rotationAxis.y * rotationAxis.z;\n        var xz = rotationAxis.x * rotationAxis.z;\n        var xs = rotationAxis.x * sin;\n        var ys = rotationAxis.y * sin;\n        var zs = rotationAxis.z * sin;\n        var f00 = rotationAxis.x * rotationAxis.x * oneMinusCos + cos;\n        var f01 = xy * oneMinusCos + zs;\n        var f02 = xz * oneMinusCos - ys;\n        var f10 = xy * oneMinusCos - zs;\n        var f11 = rotationAxis.y * rotationAxis.y * oneMinusCos + cos;\n        var f12 = yz * oneMinusCos + xs;\n        var f20 = xz * oneMinusCos + ys;\n        var f21 = yz * oneMinusCos - xs;\n        var f22 = rotationAxis.z * rotationAxis.z * oneMinusCos + cos;\n        var t00 = this.m00 * f00 + this.m10 * f01 + this.m20 * f02;\n        var t01 = this.m01 * f00 + this.m11 * f01 + this.m21 * f02;\n        var t02 = this.m02 * f00 + this.m12 * f01 + this.m22 * f02;\n        var t10 = this.m00 * f10 + this.m10 * f11 + this.m20 * f12;\n        var t11 = this.m01 * f10 + this.m11 * f11 + this.m21 * f12;\n        var t12 = this.m02 * f10 + this.m12 * f11 + this.m22 * f12;\n        dest.m20 = this.m00 * f20 + this.m10 * f21 + this.m20 * f22;\n        dest.m21 = this.m01 * f20 + this.m11 * f21 + this.m21 * f22;\n        dest.m22 = this.m02 * f20 + this.m12 * f21 + this.m22 * f22;\n        dest.m00 = t00;\n        dest.m01 = t01;\n        dest.m02 = t02;\n        dest.m10 = t10;\n        dest.m11 = t11;\n        dest.m12 = t12;\n        return dest;\n    };\n    /**\n     * Задаёт ось X матрице.\n     *\n     * @param\tv\tВектор, значения которого будут использоваться в качестве оси матрицы.\n     */\n    Mat3f.prototype.setXBasis = function (v) { this.m00 = v.x; this.m01 = v.y; this.m02 = v.z; };\n    /**\n     * Задаёт ось Y матрице.\n     *\n     * @param\tv\tВектор, значения которого будут использоваться в качестве оси матрицы.\n     */\n    Mat3f.prototype.setYBasis = function (v) { this.m10 = v.x; this.m11 = v.y; this.m12 = v.z; };\n    /**\n     * Задаёт ось Z матрице.\n     *\n     * @param\tv\tВектор, значения которого будут использоваться в качестве оси матрицы.\n     */\n    Mat3f.prototype.setZBasis = function (v) { this.m20 = v.x; this.m21 = v.y; this.m22 = v.z; };\n    Mat3f.identity = function () {\n        var a = new Float32Array(9);\n        a[0] = a[4] = a[8] = 1;\n        return a;\n    };\n    /**\n     * Возвращает новую матрицу, транспонированную версию матрицы-параметра.\n     *\n     * @param\tm\tМатрицу, которую хотят транспонировать.\n     * @return\t\tТранспонированная версия матрицы-параметра.\n     */\n    Mat3f.transpose = function (m) { return new Mat3f(m.m00, m.m10, m.m20, m.m01, m.m11, m.m21, m.m02, m.m12, m.m22); };\n    return Mat3f;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/utils/Mat3f.ts?");

/***/ }),

/***/ "./src/utils/Mat4f.ts":
/*!****************************!*\
  !*** ./src/utils/Mat4f.ts ***!
  \****************************/
/*! exports provided: Mat4f */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mat4f\", function() { return Mat4f; });\n/**\n * Матрица 4*4.\n *\n * Класс, используемый для отрисовки.\n */\nvar Mat4f = /** @class */ (function () {\n    function Mat4f() {\n        this.raw = Mat4f.identity();\n    }\n    Mat4f.prototype.vtranslate = function (v) {\n        Mat4f.translate(this.raw, v.x, v.y, v.z);\n        return this;\n    };\n    Mat4f.prototype.rotateY = function (rad) {\n        Mat4f.rotateY(this.raw, rad);\n        return this;\n    };\n    Mat4f.prototype.rotateX = function (rad) {\n        Mat4f.rotateX(this.raw, rad);\n        return this;\n    };\n    Mat4f.prototype.rotateZ = function (rad) {\n        Mat4f.rotateZ(this.raw, rad);\n        return this;\n    };\n    Mat4f.prototype.vscale = function (vec3) {\n        Mat4f.scale(this.raw, vec3.x, vec3.y, vec3.z);\n        return this;\n    };\n    Mat4f.prototype.reset = function () {\n        for (var i = 0; i < this.raw.length; i++)\n            this.raw[i] = (i % 5 === 0) ? 1 : 0;\n        return this;\n    };\n    Mat4f.identity = function () {\n        var a = new Float32Array(16);\n        a[0] = a[5] = a[10] = a[15] = 1;\n        return a;\n    };\n    Mat4f.perspective = function (out, fovy, aspect, near, far) {\n        var f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);\n        out[0] = f / aspect;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = f;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = (far + near) * nf;\n        out[11] = -1;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = (2 * far * near) * nf;\n        out[15] = 0;\n    };\n    Mat4f.normalMat3 = function (out, a) {\n        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        if (!det)\n            return null;\n        det = 1.0 / det;\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        return out;\n    };\n    Mat4f.transformVec4 = function (out, v, m) {\n        out[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        out[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        out[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        out[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n        return out;\n    };\n    Mat4f.scale = function (out, x, y, z) {\n        out[0] *= x;\n        out[1] *= x;\n        out[2] *= x;\n        out[3] *= x;\n        out[4] *= y;\n        out[5] *= y;\n        out[6] *= y;\n        out[7] *= y;\n        out[8] *= z;\n        out[9] *= z;\n        out[10] *= z;\n        out[11] *= z;\n        return out;\n    };\n    ;\n    Mat4f.rotateY = function (out, rad) {\n        var s = Math.sin(rad), c = Math.cos(rad), a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3], a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];\n        out[0] = a00 * c - a20 * s;\n        out[1] = a01 * c - a21 * s;\n        out[2] = a02 * c - a22 * s;\n        out[3] = a03 * c - a23 * s;\n        out[8] = a00 * s + a20 * c;\n        out[9] = a01 * s + a21 * c;\n        out[10] = a02 * s + a22 * c;\n        out[11] = a03 * s + a23 * c;\n        return out;\n    };\n    Mat4f.rotateX = function (out, rad) {\n        var s = Math.sin(rad), c = Math.cos(rad), a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7], a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];\n        out[4] = a10 * c + a20 * s;\n        out[5] = a11 * c + a21 * s;\n        out[6] = a12 * c + a22 * s;\n        out[7] = a13 * c + a23 * s;\n        out[8] = a20 * c - a10 * s;\n        out[9] = a21 * c - a11 * s;\n        out[10] = a22 * c - a12 * s;\n        out[11] = a23 * c - a13 * s;\n        return out;\n    };\n    Mat4f.rotateZ = function (out, rad) {\n        var s = Math.sin(rad), c = Math.cos(rad), a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3], a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];\n        out[0] = a00 * c + a10 * s;\n        out[1] = a01 * c + a11 * s;\n        out[2] = a02 * c + a12 * s;\n        out[3] = a03 * c + a13 * s;\n        out[4] = a10 * c - a00 * s;\n        out[5] = a11 * c - a01 * s;\n        out[6] = a12 * c - a02 * s;\n        out[7] = a13 * c - a03 * s;\n        return out;\n    };\n    Mat4f.invert = function (out, mat) {\n        if (mat === undefined)\n            mat = out;\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3], a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7], a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11], a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        if (!det)\n            return false;\n        det = 1.0 / det;\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n        return true;\n    };\n    Mat4f.translate = function (out, x, y, z) {\n        out[12] = out[0] * x + out[4] * y + out[8] * z + out[12];\n        out[13] = out[1] * x + out[5] * y + out[9] * z + out[13];\n        out[14] = out[2] * x + out[6] * y + out[10] * z + out[14];\n        out[15] = out[3] * x + out[7] * y + out[11] * z + out[15];\n    };\n    return Mat4f;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/utils/Mat4f.ts?");

/***/ }),

/***/ "./src/utils/Utils.ts":
/*!****************************!*\
  !*** ./src/utils/Utils.ts ***!
  \****************************/
/*! exports provided: Utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\n/* harmony import */ var _Colour4f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Colour4f */ \"./src/utils/Colour4f.ts\");\n\n/**\n * Вспомогательные методы.\n */\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    /**\n     * Возвращвет знак числа.\n     *\n     * @param\tvalue\tЧисло.\n     * @return\t\t\t1 если значение больше или равно нулю, иначе -1.\n     */\n    Utils.sign = function (value) {\n        if (value >= 0.0) {\n            return 1.0;\n        }\n        return -1.0;\n    };\n    /**\n     * Валидирует направление вектора, чтобы убедиться, что он не равен нулю.\n     * <p>\n     * Если длина вектора равна нулю бросает Error.\n     * @param\tdirectionUV     Вектор.\n     */\n    Utils.validateDirectionUV = function (directionUV) {\n        if (directionUV.length() <= 0.0) {\n            throw new Error('Vec direction unit vector cannot be zero.');\n        }\n    };\n    /**\n     * Валидирует длину кости, чтобы убедаться, что она не нулевая.\n     * <p>\n     * Если длина кости равна нулю бросает Error.\n     * @param\tlength\tДлина.\n     */\n    Utils.validateLength = function (length) {\n        if (length < 0.0) {\n            throw new Error('Length must be a greater than or equal to zero.');\n        }\n    };\n    // Константы для перевода из градусов в радианы и наоборот\n    Utils.DEGS_TO_RADS = Math.PI / 180.0;\n    Utils.RADS_TO_DEGS = 180.0 / Math.PI;\n    // Приведение чисел к формату с тремя знаками после запятой\n    Utils.formatter = function (num) { return num.toFixed(3); };\n    /**\n     * Некоторые цвета.\n     */\n    Utils.RED = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([1.0, 0.0, 0.0, 1.0]);\n    Utils.GREEN = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.0, 1.0, 0.0, 1.0]);\n    Utils.BLUE = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.0, 0.0, 1.0, 1.0]);\n    Utils.MID_RED = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.6, 0.0, 0.0, 1.0]);\n    Utils.MID_GREEN = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.0, 0.6, 0.0, 1.0]);\n    Utils.MID_BLUE = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.0, 0.0, 0.6, 1.0]);\n    Utils.BLACK = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.0, 0.0, 0.0, 1.0]);\n    Utils.GREY = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.5, 0.5, 0.5, 1.0]);\n    Utils.WHITE = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([1.0, 1.0, 1.0, 1.0]);\n    Utils.YELLOW = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([1.0, 1.0, 0.0, 1.0]);\n    Utils.CYAN = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([0.0, 1.0, 1.0, 1.0]);\n    Utils.MAGENTA = new _Colour4f__WEBPACK_IMPORTED_MODULE_0__[\"Colour4f\"]([1.0, 0.0, 1.0, 1.0]);\n    /**\n     * Возвращает котангенс угла в радианах.\n     * Return the co-tangent of an angle specified in radians.\n     *\n     * @param\tangleRads\tУгол врадианах.\n     * @return\t\t\t\tКотангенс угла.\n     */\n    Utils.cot = function (angleRads) { return (1.0 / Math.tan(angleRads)); };\n    /**\n     * Конвертирует из радиан в градусы.\n     *\n     * @param\tangleRads\tУгол в радианах.\n     * @return\t\t\t\tУгол в градусах.\n     */\n    Utils.radiansToDegrees = function (angleRads) { return angleRads * Utils.RADS_TO_DEGS; };\n    /**\n     * Конвертирует из градусов в радианы.\n     *\n     * @param\tangleDegs\tУгол в градусах.\n     * @return\t\t\t\tУгол в радианах.\n     */\n    Utils.degreesToRadians = function (angleDegs) { return angleDegs * Utils.DEGS_TO_RADS; };\n    /**\n     * Возвращает флаг, показывающий равны ли значения с заданным уровнем терпимости.\n     *\n     * @param\ta\t\tПервое значение.\n     * @param\tb\t\tВторое значение.\n     * @param\ttolerance\tМаксимальная разница между числами при которой они будут считаться равными.\n     * @return\t\t\tРавны ли значения.\n     */\n    Utils.approximatelyEquals = function (a, b, tolerance) { return (Math.abs(a - b) <= tolerance); };\n    return Utils;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/utils/Utils.ts?");

/***/ }),

/***/ "./src/utils/Vec2f.ts":
/*!****************************!*\
  !*** ./src/utils/Vec2f.ts ***!
  \****************************/
/*! exports provided: Vec2f */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vec2f\", function() { return Vec2f; });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./src/utils/Utils.ts\");\n\n/**\n * 2D вектор.\n * <p>\n * Состоит из x и y полей, задающих направление вектора.\n */\nvar Vec2f = /** @class */ (function () {\n    // ---------- Constructors ----------\n    /**\n     * Конструктор.\n     * <p>\n     * Принимает три вариации параметров:\n     * <p>\n     * Без параметров. Заполняет x и y значениями по умолчанию (нулями).\n     * <p>\n     * Конструктор копирования. Задаёт x и y равными значениям source-вектора.\n     *\n     * @param source Вектор, параметры которого будут скопированы.\n     * <p>\n     * Конструктор с двумя параметрами, задающими x и y.\n     *\n     * @param source Значение координаты по оси x.\n     * @param y Значение координаты по оси y.\n     */\n    function Vec2f(source, y) {\n        var _this = this;\n        this.x = 0;\n        this.y = 0;\n        /**\n         * Возвращает сумму данного вектора с вектором из параметров, не меняя данный вектор.\n         *\n         * @param\tv\tВектор.\n         * @return\t\tРезультат сложения данного вектора с вектором параметром.\n         **/\n        this.plus = function (v) { return new Vec2f(_this.x + v.x, _this.y + v.y); };\n        /**\n         * Возвращает разность данного вектора с вектором из параметров, не меняя данный вектор.\n         *\n         * @param\tv\tВектор.\n         * @return\t\tРезультат вычитания из данного вектора вектора-параметра.\n         **/\n        this.minus = function (v) { return new Vec2f(_this.x - v.x, _this.y - v.y); };\n        /**\n         * Умножает вектор на число и возвращает результат, не меняя при этом исходный вектор.\n         *\n         * @param\tvalue\tЧисло, на которое необходимо умножить.\n         * @return\t\t\tРезультат умножения данного вектора на число.\n         **/\n        this.times = function (value) { return new Vec2f(_this.x * value, _this.y * value); };\n        /**\n         * Делит вектор на число и возвращает результат, не меняя при этом исходный вектор.\n         *\n         * @param\tvalue\tЧисло, на которое необходимо поделить.\n         * @return\t\t\tРезультат деления данного вектора на число.\n         **/\n        this.dividedBy = function (value) { return new Vec2f(_this.x / value, _this.y / value); };\n        /**\n         * Возвращает вектор противоположного направления.\n         * Сам вектор не меняет.\n         *\n         * @return Вектор противоположного направления.\n         */\n        this.negated = function () { return new Vec2f(-_this.x, -_this.y); };\n        /**\n         * Возвращает длину вектора.\n         *\n         * @return\tДлина вектора.\n         */\n        this.length = function () { return Math.sqrt(_this.x * _this.x + _this.y * _this.y); };\n        /**\n         * Возвращает скалярное произведение двух векторов: this и вектора-параметра.\n         *\n         * @param\tv\tВторой вектор.\n         * @return\t\tСкалярное произведение.\n         */\n        this.dot = function (v) { return _this.x * v.x + _this.y * v.y; };\n        this.toArray = function () { return [_this.x, _this.y]; };\n        switch (arguments.length) {\n            case 0:\n                return;\n            case 1:\n                if (source instanceof Vec2f) {\n                    this.x = source.x;\n                    this.y = source.y;\n                    return;\n                }\n                else {\n                    throw new Error('Wrong Vec2f constructor params!');\n                }\n            case 2:\n                if (typeof source === 'number') {\n                    this.x = source;\n                    this.y = y;\n                    return;\n                }\n                else {\n                    throw new Error('Wrong Vec2f constructor params!');\n                }\n        }\n    }\n    // ---------- Methods ----------\n    /**\n     * Проверяет вектора на примерное равенство.\n     * Векторы примерно равны если модуль их координат по каждой из осей меньше tolerance.\n     * <p>\n     * Если значение tolerance меньше 0 - бросаем ошибку.\n     *\n     * @param\tv\t\t\tВектор для сравнения.\n     * @param   tolerance\tЗначение \"терпимости\" к разнице.\n     * @return\t\t\t\tРезультат сравнения.\n     */\n    Vec2f.prototype.approximatelyEquals = function (v, tolerance) {\n        if (tolerance < 0) {\n            throw new Error('Equality threshold must be greater than or equal to 0.0');\n        }\n        return (Math.abs(this.x - v.x) < tolerance && Math.abs(this.y - v.y) < tolerance);\n    };\n    /**\n     * Задаёт значения полей вектора.\n     * Принимает две вариации параметров:\n     * <p>\n     * Один параметр - вектор источник.\n     *\n     * @param\tsource\tВектор-источник.\n     * <p>\n     * Два параметра - x и y соответственно.\n     *\n     * @param\tsource\tЗначение координаты по X.\n     * @param\ty\tЗначение координаты по Y.\n     */\n    Vec2f.prototype.set = function (source, y) {\n        switch (arguments.length) {\n            case 1:\n                if (source instanceof Vec2f) {\n                    this.x = source.x;\n                    this.y = source.y;\n                    return;\n                }\n                else {\n                    throw new Error('Wrong Vec2f set params!');\n                }\n            case 2:\n                if (typeof source === 'number') {\n                    this.x = source;\n                    this.y = y;\n                    return;\n                }\n                else {\n                    throw new Error('Wrong Vec2f set params!');\n                }\n            default:\n                throw new Error('Wrong Vec2f set params!');\n        }\n    };\n    /**\n     * Нормализует и возвращает себя.\n     *\n     * @return\tНормализованный вектор.\n     */\n    Vec2f.prototype.normalise = function () {\n        var magnitude = Math.sqrt(this.x * this.x + this.y * this.y);\n        if (magnitude > 0.0) {\n            this.x /= magnitude;\n            this.y /= magnitude;\n        }\n        return this;\n    };\n    /**\n     * Возвращает нормализованную версию вектора-параметра, не меняясь сам.\n     *\n     * @param source Вектор для нормализации.\n     * @return\tНормализованный вектор.\n     */\n    Vec2f.normalised = function (source) { return new Vec2f(source).normalise(); };\n    /**\n     * Возвращает знак угла между двумя векторами.\n     * 1, если второй вектор находится против часовой стрелки относительно первого;\n     * -1, если второй вектор находится по часовой стрелке относительно первого;\n     * 0, если угол между ними 0.\n     *\n     * @param\tu\tПервый угол.\n     * @param\tv\tВторой угол.\n     * @return\t\tЗнак угла.\n     */\n    Vec2f.zcross = function (u, v) {\n        var p = u.x * v.y - v.x * u.y;\n        if (p > 0.0) {\n            return 1;\n        }\n        else {\n            if (p < 0.0) {\n                return -1;\n            }\n        }\n        return 0;\n    };\n    /**\n     * Возвращает угол со знаком между двумя векорами: this и параметром.\n     * <p>\n     * Угол будет положительным, если второй вектор находится против часовой стрелки относительно первого;\n     * Угол будет отричательным, если второй вектор находится по часовой стрелке относительно первого.\n     *\n     * @param\totherVector Второй вектор.\n     * @return\tfloat       Угол между векторами в градусах.\n     */\n    Vec2f.prototype.getSignedAngleDegsTo = function (otherVector) {\n        var thisVectorUV = Vec2f.normalised(this);\n        var otherVectorUV = Vec2f.normalised(otherVector);\n        var unsignedAngleDegs = Math.acos(thisVectorUV.dot(otherVectorUV)) * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].RADS_TO_DEGS;\n        if (Vec2f.zcross(thisVectorUV, otherVectorUV) == 1) {\n            return unsignedAngleDegs;\n        }\n        else {\n            return -unsignedAngleDegs;\n        }\n    };\n    /**\n     * Возвращает единичный вектор с примененными к нему ограничениями.\n     * Если угол между идеальным положением вектора и бейзлайном привышает ограничения, то\n     * возвращаем вектор, который повернут на граничный угол относительно бейзлайна.\n     * В противном случае - возвращаем идеальный вектор.\n     *\n     * @param\tdirectionUV\t                Идеальное положение вектора, которое возможно недостижимо.\n     * @param\tbaselineUV\t                Вектор относительно которого считаются углы.\n     * @param\tclockwiseConstraintDegs\t    Угол-ограничение по часовой стрелке.\n     * @param\tantiClockwiseConstraintDegs\tУгол-ограничение против часовой стрелки.\n     * @return\tVec2f\n     */\n    Vec2f.getConstrainedUV = function (directionUV, baselineUV, clockwiseConstraintDegs, antiClockwiseConstraintDegs) {\n        var signedAngleDegs = baselineUV.getSignedAngleDegsTo(directionUV);\n        if (signedAngleDegs > antiClockwiseConstraintDegs) {\n            return Vec2f.rotateDegs(baselineUV, antiClockwiseConstraintDegs);\n        }\n        if (signedAngleDegs < -clockwiseConstraintDegs) {\n            return Vec2f.rotateDegs(baselineUV, -clockwiseConstraintDegs);\n        }\n        return directionUV;\n    };\n    /**\n     * Вращает текущий вектор на число-параметр радиан.\n     * <p>\n     * Положительное значение угла свидетельствует о повороте против часовой стрелки.\n     * Отрицательное значеине - по часовой.\n     * <p>\n     * Меняет текущий вектор и возвращает this для создания цепочек.\n     * @param   angleRads\tTУгол поворота в радианах.\n     * @return\tVec2f\n     */\n    Vec2f.prototype.rotateRads = function (angleRads) {\n        // Поворот вокруг оси z:\n        // x' = x*cos q - y*sin q\n        // y' = x*sin q + y*cos q\n        // z' = z\n        var cosTheta = Math.cos(angleRads);\n        var sinTheta = Math.sin(angleRads);\n        var rotatedVector = new Vec2f(this.x * cosTheta - this.y * sinTheta, // x\n        this.x * sinTheta + this.y * cosTheta); // y\n        this.x = rotatedVector.x;\n        this.y = rotatedVector.y;\n        return this;\n    };\n    /**\n     * Поворачивает вектор-параметр на заданное число градусов.\n     * Method to rotate this Vec2f by a given angle as specified in degrees.\n     * <p>\n     * Метод не меняет исходный вектор.\n     * Положительное значение угла свидетельствует о повороте против часовой стрелки.\n     * Отрицательное значеине - по часовой.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleDegs\tУгол поворота в градусах.\n     * @return\tVec2f\n     */\n    Vec2f.rotateDegs = function (source, angleDegs) {\n        // Поворот вокруг оси z:\n        // x' = x*cos q - y*sin q\n        // y' = x*sin q + y*cos q\n        // z' = z\n        var angleRads = angleDegs * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].DEGS_TO_RADS;\n        var cosTheta = Math.cos(angleRads);\n        var sinTheta = Math.sin(angleRads);\n        return new Vec2f(source.x * cosTheta - source.y * sinTheta, // x\n        source.x * sinTheta + source.y * cosTheta); // y\n    };\n    /**\n     * Возвращает направление вектора, для которого a - начальная точка, а b - конечная.\n     * Направление будет единичным вектором.\n     *\n     * @param\ta\tНачальная точка.\n     * @param\tb\tКонечная точка.\n     * @return\n     */\n    Vec2f.getDirectionUV = function (a, b) { return b.minus(a).normalise(); };\n    /**\n     * Возвращает расстояние между двумя точками.\n     *\n     * @param\tv1\tНачальная позиция.\n     * @param\tv2\tКонечная позиция.\n     * @return\t\tРасстояние.\n     */\n    Vec2f.distanceBetween = function (v1, v2) { return Math.sqrt((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y)); };\n    /**\n     * Возвращает скалярное произведение двух векторов параметров.\n     *\n     * @param\tv1\tПервый вектор.\n     * @param\tv2\tВторой вектор.\n     * @return\t\tСкалярное произведение.\n     */\n    Vec2f.dot = function (v1, v2) { return v1.x * v2.x + v1.y * v2.y; };\n    /**\n     * Возвращает угол между двумя векторами-параметрами.\n     * У возвращаемого угла нет знака, все значения лежат в проеделах [0..180].\n     *\n     * @param\tv1\t    Первый вектор.\n     * @param\tv2\t    Второй вектор.\n     * @return\tfloat   Угол между векторами.\n     */\n    Vec2f.getUnsignedAngleBetweenVectorsDegs = function (v1, v2) { return Math.acos(Vec2f.normalised(v1).dot(Vec2f.normalised(v2))) * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].RADS_TO_DEGS; };\n    return Vec2f;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/utils/Vec2f.ts?");

/***/ }),

/***/ "./src/utils/Vec3f.ts":
/*!****************************!*\
  !*** ./src/utils/Vec3f.ts ***!
  \****************************/
/*! exports provided: Vec3f */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vec3f\", function() { return Vec3f; });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./src/utils/Utils.ts\");\n/* harmony import */ var _Mat3f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mat3f */ \"./src/utils/Mat3f.ts\");\n\n\n/**\n * 3D вектор.\n */\nvar Vec3f = /** @class */ (function () {\n    // ----- Methods -----\n    /**\n     * Конструктор, который принимает четыре вариации параметров:\n     * <p>\n     * Без параметров - все поля принимают значения по умолчанию.\n     * <p>\n     * Конструктор копирования. Создается глубокая копия объекта.\n     *\n     * @param value Вектор-источник\n     * <p>\n     * Конструктор с одним параметром - числом, задающим координаты вектора по всем осям.\n     *\n     * @param value Координата вектора по каждой из осей.\n     * <p>\n     * Конструктор с тремя параметрами - значения координат по X, Y, Z осям соответственно.\n     *\n     * @param value Значении координаты по оси X.\n     * @param y Значении координаты по оси Y.\n     * @param z Значении координаты по оси Z.\n     * */\n    function Vec3f(value, y, z) {\n        var _this = this;\n        // ----- Properties -----\n        // Координаты вектора\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        /**\n         * Возвращает вектор противоположного направления.\n         * Сам вектор не меняет.\n         *\n         * @return Вектор противоположного направления.\n         */\n        this.negated = function () { return new Vec3f(-_this.x, -_this.y, -_this.z); };\n        /**\n         * Возвращает векторное произведение двух векторов: this и параметра.\n         *\n         * @param\tv\tВторой вектор.\n         * @return\t\tСкалярное произведение нормализованных векторов.\n         */\n        this.cross = function (v) { return new Vec3f(_this.y * v.z - _this.z * v.y, _this.z * v.x - _this.x * v.z, _this.x * v.y - _this.y * v.x); };\n        /**\n         * Возвращает длину вектора.\n         *\n         * @return\tДлина вектора.\n         */\n        this.length = function () { return Math.sqrt(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z); };\n        /**\n         * Возвращает сумму данного вектора с вектором из параметров, не меняя данный вектор.\n         *\n         * @param\tv\tВектор.\n         * @return\t\tРезультат сложения данного вектора с вектором параметром.\n         **/\n        this.plus = function (v) { return new Vec3f(_this.x + v.x, _this.y + v.y, _this.z + v.z); };\n        /**\n         * Возвращает разность данного вектора с вектором из параметров, не меняя данный вектор.\n         *\n         * @param\tv\tВектор.\n         * @return\t\tРезультат вычитания из данного вектора вектора-параметра.\n         **/\n        this.minus = function (v) { return new Vec3f(_this.x - v.x, _this.y - v.y, _this.z - v.z); };\n        this.toArray = function () { return [_this.x, _this.y, _this.z]; };\n        switch (arguments.length) {\n            case 0: break;\n            case 1:\n                if (value instanceof Vec3f) {\n                    this.x = value.x;\n                    this.y = value.y;\n                    this.z = value.z;\n                }\n                else {\n                    this.x = this.y = this.z = value;\n                }\n                break;\n            case 3:\n                if (typeof value === 'number') {\n                    this.x = value;\n                    this.y = y;\n                    this.z = z;\n                }\n                else {\n                    throw new Error('Vec3f constructor was invoked incorrectly.');\n                }\n                break;\n        }\n    }\n    /**\n     * Задаёт значения полей вектора.\n     * Принимает две вариации параметров:\n     * <p>\n     * Один параметр - вектор источник.\n     *\n     * @param\tsource\tВектор-источник.\n     * <p>\n     * Три параметра - x, y, z соответственно.\n     *\n     * @param\tsource\tЗначение координаты по X.\n     * @param\ty\tЗначение координаты по Y.\n     * @param\tz\tЗначение координаты по Z.\n     */\n    Vec3f.prototype.set = function (source, y, z) {\n        switch (arguments.length) {\n            case 0: break;\n            case 1:\n                if (source instanceof Vec3f) {\n                    this.x = source.x;\n                    this.y = source.y;\n                    this.z = source.z;\n                }\n                else {\n                    throw new Error('Vec3f set was invoked incorrectly.');\n                }\n                break;\n            case 3:\n                if (typeof source === 'number') {\n                    this.x = source;\n                    this.y = y;\n                    this.z = z;\n                }\n                else {\n                    throw new Error('Vec3f set was invoked incorrectly.');\n                }\n                break;\n            default:\n                throw new Error('Vec3f set was invoked incorrectly.');\n        }\n    };\n    /**\n     * Проверяет вектора на примерное равенство.\n     * Векторы примерно равны если модуль их координат по каждой из осей меньше tolerance.\n     * <p>\n     * Если значение tolerance меньше 0 - бросаем ошибку.\n     *\n     * @param\tv\t\t\tВектор для сравнения.\n     * @param   tolerance\tЗначение \"терпимости\" к разнице.\n     * @return\t\t\t\tРезультат сравнения.\n     */\n    Vec3f.prototype.approximatelyEquals = function (v, tolerance) {\n        if (tolerance < 0) {\n            throw Error('Equality threshold must be greater than or equal to 0.0f');\n        }\n        var xDiff = Math.abs(this.x - v.x);\n        var yDiff = Math.abs(this.y - v.y);\n        var zDiff = Math.abs(this.z - v.z);\n        return (xDiff < tolerance && yDiff < tolerance && zDiff < tolerance);\n    };\n    /**\n     * Возвращает равна ли примерно длина данного вектора числу параметру.\n     *\n     * @param\tvalue\t\tЗначение для сравнения с длиной.\n     * @param\ttolerance\tЗначение \"терпимости\".\n     * @return\t\t\t\tРавны ли примерно длина и число-параметр.\n     */\n    Vec3f.prototype.lengthIsApproximately = function (value, tolerance) {\n        if (tolerance < 0) {\n            throw new Error('Comparison tolerance cannot be less than zero.');\n        }\n        return (Math.abs(this.length() - value) < tolerance);\n    };\n    /** Зануляет координаты данного вектора */\n    Vec3f.prototype.zero = function () { this.x = this.y = this.z = 0.0; };\n    /**\n     * Задаёт текущему вектору противоположное направление. Возвращает this для построения цепочек.\n     *\n     * @return\tВектор с противоположным направлением.\n     */\n    Vec3f.prototype.negate = function () {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n        return this;\n    };\n    /**\n     * Нормализует и возвращает себя.\n     * Если величина вектора равна нулю, то возвращается вектор без изменений.\n     *\n     * @return\tНормализованный вектор.\n     */\n    Vec3f.prototype.normalise = function () {\n        var magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        if (magnitude > 0) {\n            this.x /= magnitude;\n            this.y /= magnitude;\n            this.z /= magnitude;\n        }\n        return this;\n    };\n    /**\n     * Возвращает нормализованную версию данного вектора, не меняясь сам.\n     *\n     * @return\tНормализованный вектор.\n     */\n    Vec3f.prototype.normalised = function () { return new Vec3f(this).normalise(); };\n    /**\n     * Возвращает скалярное произведение двух нормализованных векторов переданных в параметрах.\n     *\n     * @param\tv1\tПервый вектор.\n     * @param\tv2\tВторой вектор.\n     * @return\t\tСкалярное произведение нормализованных векторов.\n     */\n    Vec3f.dotProduct = function (v1, v2) {\n        var v1Norm = v1.normalised();\n        var v2Norm = v2.normalised();\n        return v1Norm.x * v2Norm.x + v1Norm.y * v2Norm.y + v1Norm.z * v2Norm.z;\n    };\n    /**\n     * Вычисляет расстояние между двумя точками в 3D.\n     *\n     * @param\tv1\tПервая точка.\n     * @param\tv2\tВторая точка.\n     * @return\t\tРасстояние между точками.\n     */\n    Vec3f.distanceBetween = function (v1, v2) {\n        var dx = v2.x - v1.x;\n        var dy = v2.y - v1.y;\n        var dz = v2.z - v1.z;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    };\n    /**\n     * Возвращает вектор, компоненты которого - это абсолютные значения вектора-параметра.\n     * Не меняет исходный вектор.\n     *\n     * @param\tsource\tВектор.\n     * @return\t\t    Покомпонентно абсолютный аналог вектора параметра.\n     */\n    Vec3f.abs = function (source) {\n        var absVector = new Vec3f();\n        if (source.x < 0.0) {\n            absVector.x = -source.x;\n        }\n        else {\n            absVector.x = source.x;\n        }\n        if (source.y < 0.0) {\n            absVector.y = -source.y;\n        }\n        else {\n            absVector.y = source.y;\n        }\n        if (source.z < 0.0) {\n            absVector.z = -source.z;\n        }\n        else {\n            absVector.z = source.z;\n        }\n        return absVector;\n    };\n    /**\n     * Возвращает единичный вектор-перпендикуляр к вектору параметру.\n     *\n     * @param\tu\tВектор.\n     * @return\t\tЕдиничный вектор-перпендикуляр для вектора-параметра.\n     */\n    Vec3f.genPerpendicularVectorQuick = function (u) {\n        var perp;\n        if (Math.abs(u.y) < 0.99) {\n            perp = new Vec3f(-u.z, 0.0, u.x); // cross(u, UP)\n        }\n        else {\n            perp = new Vec3f(0.0, u.z, -u.y); // cross(u, RIGHT)\n        }\n        return perp.normalise();\n    };\n    /**\n     * Возвращает вектор в радианах между векторами.\n     * <p>\n     * Результат будет всегда положительным числом от 0 до pi (3.14159) радиан.\n     *\n     * @param\tv1\tПервый вектор.\n     * @param\tv2\tВторой вектор.\n     * @return\t\tУгол между векторами в радианах.\n     */\n    Vec3f.getAngleBetweenRads = function (v1, v2) {\n        // Note: a and b are normalised within the dotProduct method.\n        return Math.acos(Vec3f.dotProduct(v1, v2));\n    };\n    /**\n     * Возвращает вектор в градусах между векторами.\n     * <p>\n     * Результат будет всегда положительным числом от 0 до 180.\n     *\n     * @param\tv1\tПервый вектор.\n     * @param\tv2\tВторой вектор.\n     * @return\t\tУгол между векторами в градусах.\n     */\n    Vec3f.getAngleBetweenDegs = function (v1, v2) { return Vec3f.getAngleBetweenRads(v1, v2) * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].RADS_TO_DEGS; };\n    /**\n     * Возвращает угол между векторами [-179.9..180.0].\n     *\n     * @param\treferenceVector\tПервый, базовый вектор, от которого ведется отсчет.\n     * @param\totherVector\t\tВторой вектор.\n     * @param\tnormalVector\tВектор, первендикулярный первым двум.\n     * @return\t\t\t\t\tУгол между векторами.\n     **/\n    Vec3f.getSignedAngleBetweenDegs = function (referenceVector, otherVector, normalVector) {\n        var unsignedAngle = Vec3f.getAngleBetweenDegs(referenceVector, otherVector);\n        var sign = _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].sign(Vec3f.dotProduct(Vec3f.crossProduct(referenceVector, otherVector), normalVector));\n        return unsignedAngle * sign;\n    };\n    /**\n     * Возвращает вектор с применёнными к нему ограничениями.\n     *\n     * @param\tvecToLimit\t\tВектор поворот которого надо ограничить по отношению к базовому вектору.\n     * @param\tvecBaseline\t\tБазовый вектор.\n     * @param\tangleLimitDegs\tМаксимально допустимый угол в градусах.\n     * @return\t\t\t\t\tОграниченный вектор.\n     */\n    Vec3f.getAngleLimitedUnitVectorDegs = function (vecToLimit, vecBaseline, angleLimitDegs) {\n        var angleBetweenVectorsDegs = Vec3f.getAngleBetweenDegs(vecBaseline, vecToLimit);\n        if (angleBetweenVectorsDegs > angleLimitDegs) {\n            var correctionAxis = Vec3f.crossProduct(vecBaseline.normalised(), vecToLimit.normalised()).normalise();\n            return Vec3f.rotateAboutAxisDegs(vecBaseline, angleLimitDegs, correctionAxis).normalised();\n        }\n        else {\n            return vecToLimit.normalised();\n        }\n    };\n    /**\n     * Возвращает глобальный поворот этого вектора относительно глобальной оси X.\n     * Возвращаемое значение находится в диапазоне -179.9..180.0 степени.\n     *\n     * @return\tОтклонение вектора в градусах.\n     **/\n    Vec3f.prototype.getGlobalPitchDegs = function () {\n        var xProjected = this.projectOntoPlane(Vec3f.X_AXIS);\n        var pitch = Vec3f.getAngleBetweenDegs(Vec3f.Z_AXIS.negated(), xProjected);\n        return xProjected.y < 0.0 ? -pitch : pitch;\n    };\n    /**\n     * Возвращает глобальный поворот этого вектора относительно глобальной оси Y.\n     * Возвращаемое значение находится в диапазоне -179.9..180.0 степени.\n     *\n     * @return\tОтклонение вектора в градусах.\n     **/\n    Vec3f.prototype.getGlobalYawDegs = function () {\n        var yProjected = this.projectOntoPlane(Vec3f.Y_AXIS);\n        var yaw = Vec3f.getAngleBetweenDegs(Vec3f.Z_AXIS.negated(), yProjected);\n        return yProjected.x < 0.0 ? -yaw : yaw;\n    };\n    /**\n     * Поворачивает вектор-параметр вокруг оси X на заданный угол в радианах.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleRads\tУгол в радианах.\n     * @return\t\t\t\tПовернутый вектор.\n     */\n    Vec3f.rotateXRads = function (source, angleRads) {\n        // Поворот вокруг оси x:\n        // x' = x\n        // y' = y*cos q - z*sin q\n        // z' = y*sin q + z*cos q\n        var cosTheta = Math.cos(angleRads);\n        var sinTheta = Math.sin(angleRads);\n        return new Vec3f(source.x, source.y * cosTheta - source.z * sinTheta, source.y * sinTheta + source.z * cosTheta);\n    };\n    /**\n     * Поворачивает вектор-параметр вокруг оси X на заданный угол в градусах.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleDegs\tУгол в градусах.\n     * @return\t\t\t\tПовернутый вектор.\n     */\n    Vec3f.rotateXDegs = function (source, angleDegs) { return Vec3f.rotateXRads(source, angleDegs * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].DEGS_TO_RADS); };\n    /**\n     * Поворачивает вектор-параметр вокруг оси Y на заданный угол в радианах.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleRads\tУгол в радианах.\n     * @return\t\t\t\tПовернутый вектор.\n     */\n    Vec3f.rotateYRads = function (source, angleRads) {\n        // Поворот вокруг оси y:\n        // x' = z*sin q + x*cos q\n        // y' = y\n        // z' = z*cos q - x*sin q\n        var cosTheta = Math.cos(angleRads);\n        var sinTheta = Math.sin(angleRads);\n        return new Vec3f(source.z * sinTheta + source.x * cosTheta, source.y, source.z * cosTheta - source.x * sinTheta);\n    };\n    /**\n     * Поворачивает вектор-параметр вокруг оси Y на заданный угол в градусах.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleDegs\tУгол в градусах.\n     * @return\t\t\t\tПовернутый вектор.\n     */\n    Vec3f.rotateYDegs = function (source, angleDegs) { return Vec3f.rotateYRads(source, angleDegs * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].DEGS_TO_RADS); };\n    /**\n     * Поворачивает вектор-параметр вокруг оси Z на заданный угол в радианах.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleRads\tУгол в радианах.\n     * @return\t\t\t\tПовернутый вектор.\n     */\n    Vec3f.rotateZRads = function (source, angleRads) {\n        // Поворот вокруг оси z:\n        // x' = x*cos q - y*sin q\n        // y' = x*sin q + y*cos q\n        // z' = z\n        var cosTheta = Math.cos(angleRads);\n        var sinTheta = Math.sin(angleRads);\n        return new Vec3f(source.x * cosTheta - source.y * sinTheta, source.x * sinTheta + source.y * cosTheta, source.z);\n    };\n    /**\n     * Поворачивает вектор-параметр вокруг оси Z на заданный угол в градусах.\n     *\n     * @param\tsource\t\tВектор для поворота.\n     * @param\tangleDegs\tУгол в градусах.\n     * @return\t\t\t\tПовернутый вектор.\n     */\n    Vec3f.rotateZDegs = function (source, angleDegs) { return Vec3f.rotateZRads(source, angleDegs * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].DEGS_TO_RADS); };\n    /**\n     * Поворачивает вектор относительно оси.\n     *\n     * @param source\t\tВектор для поворота.\n     * @param angleDegs\t\tУгол поворота в радианах.\n     * @param rotationAxis\tОсь вращения.\n     * @return\t\t\t\tИсходный вектор, повернутый на нужный угол.\n     */\n    Vec3f.rotateAboutAxisRads = function (source, angleRads, rotationAxis) {\n        var rotationMatrix = new _Mat3f__WEBPACK_IMPORTED_MODULE_1__[\"Mat3f\"]();\n        var sinTheta = Math.sin(angleRads);\n        var cosTheta = Math.cos(angleRads);\n        var oneMinusCosTheta = 1.0 - cosTheta;\n        var xyOne = rotationAxis.x * rotationAxis.y * oneMinusCosTheta;\n        var xzOne = rotationAxis.x * rotationAxis.z * oneMinusCosTheta;\n        var yzOne = rotationAxis.y * rotationAxis.z * oneMinusCosTheta;\n        rotationMatrix.m00 = rotationAxis.x * rotationAxis.x * oneMinusCosTheta + cosTheta;\n        rotationMatrix.m01 = xyOne + rotationAxis.z * sinTheta;\n        rotationMatrix.m02 = xzOne - rotationAxis.y * sinTheta;\n        rotationMatrix.m10 = xyOne - rotationAxis.z * sinTheta;\n        rotationMatrix.m11 = rotationAxis.y * rotationAxis.y * oneMinusCosTheta + cosTheta;\n        rotationMatrix.m12 = yzOne + rotationAxis.x * sinTheta;\n        rotationMatrix.m20 = xzOne + rotationAxis.y * sinTheta;\n        rotationMatrix.m21 = yzOne - rotationAxis.x * sinTheta;\n        rotationMatrix.m22 = rotationAxis.z * rotationAxis.z * oneMinusCosTheta + cosTheta;\n        return rotationMatrix.times(source);\n    };\n    /**\n     * Поворачивает вектор относительно оси.\n     *\n     * @param source\t\tВектор для поворота.\n     * @param angleDegs\t\tУгол поворота в градусах.\n     * @param rotationAxis\tОсь вращения.\n     * @return\t\t\t\tИсходный вектор, повернутый на нужный градус.\n     */\n    Vec3f.rotateAboutAxisDegs = function (source, angleDegs, rotationAxis) {\n        return Vec3f.rotateAboutAxisRads(source, angleDegs * _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].DEGS_TO_RADS, rotationAxis);\n    };\n    /**\n     * Возвращает новый вектор, у которого каждая компонента домноженный на число или\n     * на соответствующую компоненту вектора-параметра.\n     *\n     * @param\tscale\tЧисло или вектор.\n     * @return\n     **/\n    Vec3f.prototype.times = function (scale) {\n        if (scale instanceof Vec3f) {\n            return new Vec3f(this.x * scale.x, this.y * scale.y, this.z * scale.z);\n        }\n        else {\n            return new Vec3f(this.x * scale, this.y * scale, this.z * scale);\n        }\n    };\n    /**\n     * Домножает каждую компоненту вектора-параметра на число-параметр.\n     *\n     * @param\tv\t\tВектор.\n     * @param\tscale\tЧисло, на которое надо домножить.\n     **/\n    Vec3f.times = function (v, scale) { v.x *= scale; v.y *= scale; v.z *= scale; };\n    /**\n     * Покомпонентно складывает два вектора, записывая результат в первый.\n     *\n     *  @param\tsource\tВектор, в который запишется результат сложения.\n     *  @param\tother\tВторой вектор.\n     */\n    Vec3f.add = function (source, other) { source.x += other.x; source.y += other.y; source.z += other.z; };\n    /**\n     * Покомпонентно вычитает из первого вектора второй, модифицируя первый.\n     *\n     *  @param\tsource\tВектор, который будет содержать результат.\n     *  @param\tother\tВторой вектор.\n     */\n    Vec3f.subtract = function (source, other) { source.x -= other.x; source.y -= other.y; source.z -= other.z; };\n    /**\n     * Делит вектор на число и возвращает результат, не меняя при этом исходный вектор.\n     *\n     * @param\tvalue\tЧисло, на которое необходимо поделить.\n     * @return\t\t\tРезультат деления данного вектора на число.\n     **/\n    Vec3f.prototype.dividedBy = function (value) { return new Vec3f(this.x / value, this.y / value, this.z / value); };\n    /**\n     * Возвращает проекцию вектора на плоскость.\n     *\n     * @param\tplaneNormal\tНормаль к плоскости.\n     * @return\t\t\t\tПроекция вектора.\n     */\n    Vec3f.prototype.projectOntoPlane = function (planeNormal) {\n        if (!(planeNormal.length() > 0.0)) {\n            throw new Error('Plane normal cannot be a zero vector.');\n        }\n        // Проекция вектора b на плоскость с нормалью n : b - ( b.n / ( |n| squared )) * n\n        var b = this.normalised();\n        var n = planeNormal.normalised();\n        return b.minus(n.times(Vec3f.dotProduct(b, planeNormal))).normalise();\n    };\n    /**\n     * Возвращает направление вектора, для которого v1 - начальная точка, а v2 - конечная.\n     * Направление будет единичным вектором.\n     *\n     * @param\tv1\tНачальная точка.\n     * @param\tv2\tКонечная точка.\n     * @return\n     */\n    Vec3f.getDirectionUV = function (v1, v2) { return v2.minus(v1).normalise(); };\n    // Координатные оси\n    Vec3f.X_AXIS = new Vec3f(1, 0, 0);\n    Vec3f.Y_AXIS = new Vec3f(0, 1, 0);\n    Vec3f.Z_AXIS = new Vec3f(0, 0, 1);\n    /**\n     * Возвращает копию вектора-источника.\n     *\n     * @param\tsource\tВектор-источник.\n     * @return\t\t    Глубокая копия вектора источника .\n     */\n    Vec3f.clone = function (source) { return new Vec3f(source.x, source.y, source.z); };\n    /**\n     * Возвращает перпендикулярны ли два вектора.\n     *\n     * @param\ta\tПервый вектор.\n     * @param\tb\tВторой вектор.\n     * @return\t\tПерпендикулярны ли они.\n     */\n    Vec3f.perpendicular = function (a, b) { return _Utils__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].approximatelyEquals(Vec3f.dotProduct(a, b), 0.0, 0.01); };\n    /**\n     * Возвращает равны ли примерно вектора при заданном уровне \"терпимости\".\n     *\n     * @param\ta\t\tПервый вектор.\n     * @param\tb\t\tВторой вектор.\n     * @param\ttolerance\tУровень \"терпимости\", максимальная разница между векторами, при которой они всё еще равны.\n     * @return\n     */\n    Vec3f.approximatelyEqual = function (a, b, tolerance) { return ((Math.abs(a.x - b.x) < tolerance)\n        && (Math.abs(a.y - b.y) < tolerance)\n        && (Math.abs(a.z - b.z) < tolerance)); };\n    /**\n     * Возвращает скалярное произведение двух векторов переданных в параметрах.\n     *\n     * @param\tv1\tПервый вектор.\n     * @param\tv2\tВторой вектор.\n     * @return\t\tСкалярное произведение.\n     */\n    Vec3f.scalarProduct = function (v1, v2) { return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z; };\n    /**\n     * Возвращает векторное произведение двух векторов переданных в параметрах.\n     *\n     * @param\tv1\tПервый вектор.\n     * @param\tv2\tВторой вектор.\n     * @return\t\tВекторное произведение векторов.\n     */\n    Vec3f.crossProduct = function (v1, v2) { return new Vec3f(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x); };\n    /**\n     * Возвращает единичный вектор-направление от первой точки ко второй.\n     *\n     * @param\tv1\tПервая точка.\n     * @param\tv2\tВторая точка.\n     * @return\t\tЕдиничный вектор-направление.\n     */\n    Vec3f.getUvBetween = function (v1, v2) { return new Vec3f(v2.minus(v1)).normalise(); };\n    return Vec3f;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/utils/Vec3f.ts?");

/***/ }),

/***/ "./src/visualisation/Camera.ts":
/*!*************************************!*\
  !*** ./src/visualisation/Camera.ts ***!
  \*************************************/
/*! exports provided: Camera, CameraController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CameraController\", function() { return CameraController; });\n/* harmony import */ var _utils_Mat4f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Mat4f */ \"./src/utils/Mat4f.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transform */ \"./src/visualisation/Transform.ts\");\n/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scene */ \"./src/visualisation/Scene.ts\");\n\n\n\n\n/**\n * Камера в сцене.\n */\nvar Camera = /** @class */ (function () {\n    function Camera(gl, fov, near, far) {\n        if (fov === void 0) { fov = 45; }\n        if (near === void 0) { near = 0.1; }\n        if (far === void 0) { far = 100.0; }\n        this.projectionMatrix = new Float32Array(16);\n        var ratio = gl.canvas.width / gl.canvas.height;\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_0__[\"Mat4f\"].perspective(this.projectionMatrix, fov, ratio, near, far);\n        this.transform = new _Transform__WEBPACK_IMPORTED_MODULE_2__[\"Transform\"]();\n        this.viewMatrix = new Float32Array(16);\n    }\n    Camera.prototype.panX = function (v) {\n        this.updateViewMatrix();\n        this.transform.position.x += v;\n    };\n    Camera.prototype.panY = function (v) {\n        this.updateViewMatrix();\n        this.transform.position.y += this.transform.up[1] * v;\n    };\n    Camera.prototype.panZ = function (v) {\n        this.updateViewMatrix();\n        this.transform.position.z += v;\n    };\n    Camera.prototype.updateViewMatrix = function () {\n        this.transform.matView.reset()\n            .rotateX(this.transform.rotation.x * _utils_Utils__WEBPACK_IMPORTED_MODULE_1__[\"Utils\"].DEGS_TO_RADS)\n            .rotateY(this.transform.rotation.y * _utils_Utils__WEBPACK_IMPORTED_MODULE_1__[\"Utils\"].DEGS_TO_RADS)\n            .vtranslate(this.transform.position);\n        this.transform.updateDirection();\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_0__[\"Mat4f\"].invert(this.viewMatrix, this.transform.matView.raw);\n        return this.viewMatrix;\n    };\n    return Camera;\n}());\n\n/**\n * Меняет положение камеры в ответ на действия пользователя.\n */\nvar CameraController = /** @class */ (function () {\n    function CameraController(gl, camera) {\n        this.rotateRate = -300;\n        this.panRate = 5;\n        this.zoomRate = 200;\n        this.prevX = 0;\n        this.prevY = 0;\n        var oThis = this;\n        var box = gl.canvas.getBoundingClientRect();\n        this.canvas = gl.canvas;\n        this.camera = camera;\n        this.offsetX = box.left;\n        this.offsetY = box.top;\n        if (_Scene__WEBPACK_IMPORTED_MODULE_3__[\"DIMENSION\"] !== 2) {\n            this.onUpHandler = function () {\n                oThis.onMouseUp();\n            };\n            this.onMoveHandler = function (e) {\n                oThis.onMouseMove(e);\n            };\n            this.canvas.addEventListener('mousedown', function (e) {\n                oThis.onMouseDown(e);\n            });\n            this.canvas.addEventListener('mousewheel', function (e) {\n                oThis.onMouseWheel(e);\n            });\n        }\n    }\n    CameraController.prototype.onMouseDown = function (e) {\n        this.prevX = e.pageX - this.offsetX;\n        this.prevY = e.pageY - this.offsetY;\n        this.canvas.addEventListener('mouseup', this.onUpHandler);\n        this.canvas.addEventListener('mousemove', this.onMoveHandler);\n    };\n    CameraController.prototype.onMouseUp = function () {\n        this.canvas.removeEventListener('mouseup', this.onUpHandler);\n        this.canvas.removeEventListener('mousemove', this.onMoveHandler);\n    };\n    CameraController.prototype.onMouseWheel = function (e) {\n        var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));\n        this.camera.panZ(delta * (this.zoomRate / this.canvas.height));\n    };\n    CameraController.prototype.onMouseMove = function (e) {\n        var x = e.pageX - this.offsetX, y = e.pageY - this.offsetY, dx = x - this.prevX, dy = y - this.prevY;\n        if (!e.shiftKey) {\n            this.camera.transform.rotation.y += dx * (this.rotateRate / this.canvas.width);\n            this.camera.transform.rotation.x += dy * (this.rotateRate / this.canvas.height);\n        }\n        else {\n            this.camera.panX(-dx * (this.panRate / this.canvas.width));\n            this.camera.panY(dy * (this.panRate / this.canvas.height));\n        }\n        this.prevX = x;\n        this.prevY = y;\n    };\n    return CameraController;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/Camera.ts?");

/***/ }),

/***/ "./src/visualisation/Modal.ts":
/*!************************************!*\
  !*** ./src/visualisation/Modal.ts ***!
  \************************************/
/*! exports provided: Modal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Modal\", function() { return Modal; });\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transform */ \"./src/visualisation/Transform.ts\");\n\n/**\n * Универсальное представление отрисовываемого объекта.\n * Содержит в себе исходные данные об объекте, а также его положение относительно мировых координат.\n */\nvar Modal = /** @class */ (function () {\n    function Modal(meshData) {\n        this.transform = new _Transform__WEBPACK_IMPORTED_MODULE_0__[\"Transform\"]();\n        this.mesh = meshData;\n    }\n    Modal.prototype.setScale = function (x, y, z) {\n        this.transform.scale.set(x, y, z);\n        return this;\n    };\n    Modal.prototype.setPosition = function (x, y, z) {\n        this.transform.position.set(x, y, z);\n        return this;\n    };\n    Modal.prototype.setRotation = function (x, y, z) {\n        this.transform.rotation.set(x, y, z);\n        return this;\n    };\n    Modal.prototype.addScale = function (x, y, z) {\n        this.transform.scale.x += x;\n        this.transform.scale.y += y;\n        this.transform.scale.z += z;\n        return this;\n    };\n    Modal.prototype.addPosition = function (x, y, z) {\n        this.transform.position.x += x;\n        this.transform.position.y += y;\n        this.transform.position.z += z;\n        return this;\n    };\n    Modal.prototype.addRotation = function (x, y, z) {\n        this.transform.rotation.x += x;\n        this.transform.rotation.y += y;\n        this.transform.rotation.z += z;\n        return this;\n    };\n    Modal.prototype.preRender = function () {\n        this.transform.updateMatrix();\n        return this;\n    };\n    return Modal;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/Modal.ts?");

/***/ }),

/***/ "./src/visualisation/Primatives.ts":
/*!*****************************************!*\
  !*** ./src/visualisation/Primatives.ts ***!
  \*****************************************/
/*! exports provided: Primatives */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Primatives\", function() { return Primatives; });\n/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Modal */ \"./src/visualisation/Modal.ts\");\n/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Scene */ \"./src/visualisation/Scene.ts\");\n\n\n/**\n * Объекты.\n */\nvar Primatives = {};\nPrimatives.Primitive = /** @class */ (function () {\n    function Primitive() {\n    }\n    Primitive.createModal = function (gl, name, verts, colors) {\n        return new _Modal__WEBPACK_IMPORTED_MODULE_0__[\"Modal\"](Primatives.Primitive.createMesh(gl, name, verts, colors));\n    };\n    Primitive.createMesh = function (gl, name, verts, colors) {\n        var mesh = gl.fCreateMeshVAO(name, verts, colors, gl.LINES);\n        mesh.noCulling = true;\n        mesh.doBlending = true;\n        return mesh;\n    };\n    return Primitive;\n}());\nPrimatives.Point = /** @class */ (function () {\n    function Point() {\n    }\n    Point.createModal = function (gl, name, verts, colors) {\n        return new _Modal__WEBPACK_IMPORTED_MODULE_0__[\"Modal\"](Primatives.Point.createMesh(gl, name, verts, colors));\n    };\n    Point.createMesh = function (gl, name, verts, colors) {\n        var mesh = gl.fCreateMeshVAO(name, verts, colors, gl.POINTS);\n        mesh.noCulling = true;\n        mesh.doBlending = true;\n        return mesh;\n    };\n    return Point;\n}());\nPrimatives.GridAxis = /** @class */ (function () {\n    function class_1() {\n    }\n    class_1.createModal = function (gl, incAxis) {\n        return new _Modal__WEBPACK_IMPORTED_MODULE_0__[\"Modal\"](Primatives.GridAxis.createMesh(gl, incAxis));\n    };\n    class_1.createMesh = function (gl, incAxis) {\n        var verts = [], size = _Scene__WEBPACK_IMPORTED_MODULE_1__[\"DIMENSION\"] === 2 ? 7 : 2, div = _Scene__WEBPACK_IMPORTED_MODULE_1__[\"DIMENSION\"] === 2 ? 20 : 10, step = size / div, half = size / 2;\n        var p;\n        if (_Scene__WEBPACK_IMPORTED_MODULE_1__[\"DIMENSION\"] === 2) {\n            for (var i = 0; i <= div; i++) {\n                p = -half + (i * step);\n                verts.push(p);\n                verts.push(half);\n                verts.push(0);\n                verts.push(0);\n                verts.push(p);\n                verts.push(-half);\n                verts.push(0);\n                verts.push(0);\n                p = half - (i * step);\n                verts.push(-half);\n                verts.push(p);\n                verts.push(0);\n                verts.push(0);\n                verts.push(half);\n                verts.push(p);\n                verts.push(0);\n                verts.push(0);\n            }\n        }\n        else {\n            for (var i = 0; i <= div; i++) {\n                p = -half + (i * step);\n                verts.push(p);\n                verts.push(0);\n                verts.push(half);\n                verts.push(0);\n                verts.push(p);\n                verts.push(0);\n                verts.push(-half);\n                verts.push(0);\n                p = half - (i * step);\n                verts.push(-half);\n                verts.push(0);\n                verts.push(p);\n                verts.push(0);\n                verts.push(half);\n                verts.push(0);\n                verts.push(p);\n                verts.push(0);\n            }\n        }\n        if (incAxis) {\n            verts.push(-size / 2);\n            verts.push(0);\n            verts.push(0);\n            verts.push(1);\n            verts.push(size / 2);\n            verts.push(0);\n            verts.push(0);\n            verts.push(1);\n            verts.push(0);\n            verts.push(-size / 2);\n            verts.push(0);\n            verts.push(2);\n            verts.push(0);\n            verts.push(size / 2);\n            verts.push(0);\n            verts.push(2);\n            verts.push(0);\n            verts.push(0);\n            verts.push(-size / 2);\n            verts.push(3);\n            verts.push(0);\n            verts.push(0);\n            verts.push(size / 2);\n            verts.push(3);\n        }\n        var attrColorLoc = 4, strideLen, mesh = { drawMode: gl.LINES, vao: gl.createVertexArray() };\n        mesh.vertexComponentLen = 4;\n        mesh.vertexCount = verts.length / mesh.vertexComponentLen;\n        strideLen = Float32Array.BYTES_PER_ELEMENT * mesh.vertexComponentLen;\n        mesh.bufVertices = gl.createBuffer();\n        gl.bindVertexArray(mesh.vao);\n        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.bufVertices);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(_Scene__WEBPACK_IMPORTED_MODULE_1__[\"ATTR_POSITION_LOC\"]);\n        gl.enableVertexAttribArray(attrColorLoc);\n        gl.vertexAttribPointer(_Scene__WEBPACK_IMPORTED_MODULE_1__[\"ATTR_POSITION_LOC\"], 3, gl.FLOAT, false, strideLen, 0);\n        gl.vertexAttribPointer(attrColorLoc, 1, gl.FLOAT, false, strideLen, Float32Array.BYTES_PER_ELEMENT * 3);\n        gl.bindVertexArray(null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.mMeshCache['grid'] = mesh;\n        return mesh;\n    };\n    return class_1;\n}());\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/Primatives.ts?");

/***/ }),

/***/ "./src/visualisation/RenderLoop.ts":
/*!*****************************************!*\
  !*** ./src/visualisation/RenderLoop.ts ***!
  \*****************************************/
/*! exports provided: RenderLoop */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderLoop\", function() { return RenderLoop; });\n/**\n * Контролирует перерисовку сцены.\n *\n * Tutorial on how to control FPS :: http://codetheory.in/controlling-the-frame-rate-with-requestanimationframe/\n * EXAMPLE:\n * rloop = new RenderLoop(function(dt){\n *     console.log(rloop.fps + ' ' + dt);\n * },10).start();\n*/\nvar RenderLoop = /** @class */ (function () {\n    function RenderLoop(callback, fps) {\n        var oThis = this;\n        this.msLastFrame = null; // Время в миллисекундах последнего кадра.\n        this.callBack = callback; // Какую функцию вызывать для каждого кадра.\n        this.isActive = false; // Управление состоянием включения/выключения цикла рендеринга.\n        this.fps = 0; // Хранит значение скорости цикла.\n        if (fps !== undefined && fps > 0) { // Создать метод run, который ограничивает частоту кадров.\n            this.msFpsLimit = 1000 / fps; // Считаем, сколько миллисекунд на кадр в одной секунде времени.\n            this.run = function () {\n                // Вычислите Deltatime между кадрами и FPS в настоящее время.\n                var msCurrent = performance.now(), msDelta = (msCurrent - oThis.msLastFrame), deltaTime = msDelta / 1000.0; // Какую долю секунды составляет Deltatime.\n                if (msDelta >= oThis.msFpsLimit) { // Теперь выполним кадр как только истечет время.\n                    oThis.fps = Math.floor(1 / deltaTime);\n                    oThis.msLastFrame = msCurrent;\n                    oThis.callBack(deltaTime);\n                }\n                if (oThis.isActive)\n                    window.requestAnimationFrame(oThis.run);\n            };\n        }\n        else { // В противном случае создайте метод run, который максимально оптимизирован.\n            this.run = function () {\n                // Вычислите Deltatime между кадрами и FPS в настоящее время.\n                var msCurrent = performance.now(), deltaTime = (msCurrent - oThis.msLastFrame) / 1000.0; // Какую долю секунды составляет Deltatime.\n                // Теперь выполним кадр как только истечет время.\n                oThis.fps = Math.floor(1 / deltaTime); // Время, необходимое для создания одного кадра, разделите 1 на это, чтобы получить сколько кадров за одну секунду происходит.\n                oThis.msLastFrame = msCurrent;\n                oThis.callBack(deltaTime);\n                if (oThis.isActive)\n                    window.requestAnimationFrame(oThis.run);\n            };\n        }\n    }\n    RenderLoop.prototype.start = function () {\n        this.isActive = true;\n        this.msLastFrame = performance.now();\n        window.requestAnimationFrame(this.run);\n        return this;\n    };\n    RenderLoop.prototype.stop = function () {\n        this.isActive = false;\n    };\n    return RenderLoop;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/RenderLoop.ts?");

/***/ }),

/***/ "./src/visualisation/Scene.ts":
/*!************************************!*\
  !*** ./src/visualisation/Scene.ts ***!
  \************************************/
/*! exports provided: ATTR_POSITION_NAME, ATTR_POSITION_LOC, ATTR_COLOR_NAME, ATTR_COLOR_LOC, DIMENSION, Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ATTR_POSITION_NAME\", function() { return ATTR_POSITION_NAME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ATTR_POSITION_LOC\", function() { return ATTR_POSITION_LOC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ATTR_COLOR_NAME\", function() { return ATTR_COLOR_NAME; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ATTR_COLOR_LOC\", function() { return ATTR_COLOR_LOC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIMENSION\", function() { return DIMENSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera */ \"./src/visualisation/Camera.ts\");\n/* harmony import */ var _Primatives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Primatives */ \"./src/visualisation/Primatives.ts\");\n/* harmony import */ var _Shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Shaders */ \"./src/visualisation/Shaders.ts\");\n/* harmony import */ var _RenderLoop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderLoop */ \"./src/visualisation/RenderLoop.ts\");\n\n\n\n\nvar ATTR_POSITION_NAME = 'a_position';\nvar ATTR_POSITION_LOC = 0;\nvar ATTR_COLOR_NAME = 'a_color';\nvar ATTR_COLOR_LOC = 1;\nvar DIMENSION = 3;\n/**\n * Сцена.\n */\nvar Scene = /** @class */ (function () {\n    function Scene(canvasID, dimension) {\n        var _this = this;\n        this._primitives = [];\n        this._points = [];\n        this.onRender = function () {\n            _this.gCamera.updateViewMatrix();\n            _this.gl.fClear();\n            _this.gGridShader.activate()\n                .setCameraMatrix(_this.gCamera.viewMatrix)\n                .renderModal(_this.gGridModal.preRender());\n            for (var _i = 0, _a = _this._primitives; _i < _a.length; _i++) {\n                var primitive = _a[_i];\n                primitive.gShader.activate()\n                    .setCameraMatrix(_this.gCamera.viewMatrix)\n                    .renderModal(primitive.gModal.preRender());\n            }\n            for (var _b = 0, _c = _this._points; _b < _c.length; _b++) {\n                var point = _c[_b];\n                point.gShader.activate()\n                    .setCameraMatrix(_this.gCamera.viewMatrix)\n                    .renderModal(point.gModal.preRender());\n            }\n        };\n        if (dimension === 2) {\n            DIMENSION = dimension;\n        }\n        this.canvas = document.getElementById(canvasID);\n        var gl = this.gl = this.canvas.getContext('webgl2');\n        if (!gl) {\n            console.error('WebGL context is not available.');\n            return;\n        }\n        gl.mMeshCache = []; // Будем кешировать всё, что рисуем на сцене.\n        // Задаём необходимые конфигурации сцене.\n        gl.cullFace(gl.BACK); // Back is also default\n        gl.frontFace(gl.CCW); // Dont really need to set it, its ccw by default.\n        gl.enable(gl.DEPTH_TEST); // Shouldn't use this, use something else to add depth detection\n        gl.enable(gl.CULL_FACE); // Cull back face, so only show triangles that are created clockwise\n        gl.depthFunc(gl.LEQUAL); // Near things obscure far things\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // Setup default alpha blending\n        gl.clearColor(1.0, 1.0, 1.0, 1.0); // Set clear color\n        //  Чистим канвас от всего, что изображено.\n        gl.fClear = function () {\n            this.clear(this.COLOR_BUFFER_BIT | this.DEPTH_BUFFER_BIT);\n            return this;\n        };\n        // Создаём и заполняем буффер.\n        gl.fCreateArrayBuffer = function (floatAry, isStatic) {\n            if (isStatic === void 0) { isStatic = true; }\n            var buf = this.createBuffer();\n            this.bindBuffer(this.ARRAY_BUFFER, buf);\n            this.bufferData(this.ARRAY_BUFFER, floatAry, (isStatic) ? this.STATIC_DRAW : this.DYNAMIC_DRAW);\n            this.bindBuffer(this.ARRAY_BUFFER, null);\n            return buf;\n        };\n        // Превращаем массивы в GL буферы и заполняем VAO, которые будут предопределять буферы стандартных атрибутов шейдера.\n        gl.fCreateMeshVAO = function (name, arrVert, arrCol, drawMode) {\n            if (drawMode === void 0) { drawMode = this.LINES; }\n            var res = { drawMode: drawMode };\n            res.vao = this.createVertexArray();\n            this.bindVertexArray(res.vao);\n            //.......................................................\n            // Задаём константы\n            if (arrVert) {\n                res.bufVertices = this.createBuffer();\n                res.vertexComponentLen = 3;\n                res.vertexCount = arrVert.length / res.vertexComponentLen;\n                this.bindBuffer(this.ARRAY_BUFFER, res.bufVertices);\n                this.bufferData(this.ARRAY_BUFFER, new Float32Array(arrVert), this.STATIC_DRAW);\n                this.enableVertexAttribArray(ATTR_POSITION_LOC);\n                this.vertexAttribPointer(ATTR_POSITION_LOC, 3, this.FLOAT, false, 0, 0);\n            }\n            //.......................................................\n            // Задаём цвета\n            if (arrCol) {\n                res.bufColors = this.createBuffer();\n                this.bindBuffer(this.ARRAY_BUFFER, res.bufColors);\n                this.bufferData(this.ARRAY_BUFFER, new Float32Array(arrCol), this.STATIC_DRAW);\n                this.enableVertexAttribArray(ATTR_COLOR_LOC);\n                this.vertexAttribPointer(ATTR_COLOR_LOC, 4, this.FLOAT, false, 0, 0);\n            }\n            this.bindVertexArray(null); // !!!\n            this.bindBuffer(this.ARRAY_BUFFER, null);\n            this.mMeshCache[name] = res;\n            return res;\n        };\n        gl.fSetSize = function (w, h) {\n            this.canvas.style.width = w + 'px';\n            this.canvas.style.height = h + 'px';\n            this.canvas.width = w;\n            this.canvas.height = h;\n            this.viewport(0, 0, w, h);\n            return this;\n        };\n        gl.fFitScreen = function (wp, hp) {\n            if (wp === void 0) { wp = 1; }\n            if (hp === void 0) { hp = 1; }\n            return this.fSetSize(window.innerWidth * wp, window.innerHeight * hp);\n        };\n    }\n    Scene.prototype.init = function (incAxis) {\n        this.gl.fFitScreen(1, 1).fClear();\n        this.gCamera = new _Camera__WEBPACK_IMPORTED_MODULE_0__[\"Camera\"](this.gl);\n        this.gCamera.transform.position.set(0, DIMENSION === 2 ? 0 : 0.3, 3);\n        this.gCameraCtrl = new _Camera__WEBPACK_IMPORTED_MODULE_0__[\"CameraController\"](this.gl, this.gCamera);\n        this.gGridShader = new _Shaders__WEBPACK_IMPORTED_MODULE_2__[\"GridAxisShader\"](this.gl, this.gCamera.projectionMatrix);\n        this.gGridModal = _Primatives__WEBPACK_IMPORTED_MODULE_1__[\"Primatives\"].GridAxis.createModal(this.gl, incAxis);\n        this.RLoop = new _RenderLoop__WEBPACK_IMPORTED_MODULE_3__[\"RenderLoop\"](this.onRender, 30).start();\n    };\n    Scene.prototype.addPrimitive = function (structure) {\n        var prim = new Primitive(this.gl, this.gCamera, structure);\n        this._primitives.push(prim);\n        return prim;\n    };\n    Scene.prototype.addPoint = function (vec, color) {\n        this._points.push(new Point(this.gl, this.gCamera, vec, color));\n    };\n    return Scene;\n}());\n\n/**\n * Точка.\n */\nvar Point = /** @class */ (function () {\n    function Point(gl, camera, vec, color) {\n        this.gShader = new _Shaders__WEBPACK_IMPORTED_MODULE_2__[\"Primitive2DShader\"](gl, camera.projectionMatrix);\n        this.gModal = _Primatives__WEBPACK_IMPORTED_MODULE_1__[\"Primatives\"].Point.createModal(gl, 'point', vec.toArray(), color.toArray());\n    }\n    return Point;\n}());\n/**\n * Скелет.\n */\nvar Primitive = /** @class */ (function () {\n    function Primitive(gl, camera, structure) {\n        this.structure = structure;\n        this.parseStructure();\n        this.gl = gl;\n        this.gShader = new _Shaders__WEBPACK_IMPORTED_MODULE_2__[\"Primitive2DShader\"](gl, camera.projectionMatrix);\n        this.gModal = _Primatives__WEBPACK_IMPORTED_MODULE_1__[\"Primatives\"].Primitive.createModal(gl, this.name, this.verts, this.colors);\n    }\n    Primitive.prototype.parseStructure = function () {\n        var _a, _b, _c, _d;\n        this.name = this.structure.getName();\n        this.effectors = [];\n        this.colors = [];\n        this.verts = [];\n        for (var i = 0; i < this.structure.getNumChains(); i++) {\n            for (var _i = 0, _e = this.structure.getChain(i).getChain(); _i < _e.length; _i++) {\n                var bone = _e[_i];\n                (_a = this.colors).push.apply(_a, bone.getColour().toArray());\n                (_b = this.colors).push.apply(_b, bone.getColour().toArray());\n                (_c = this.verts).push.apply(_c, bone.getStartLocationAsArray());\n                if (DIMENSION === 2)\n                    this.verts.push(0);\n                (_d = this.verts).push.apply(_d, bone.getEndLocationAsArray());\n                if (DIMENSION === 2)\n                    this.verts.push(0);\n            }\n            this.effectors.push(this.structure.getChain(i));\n        }\n    };\n    Primitive.prototype.moveTo = function (index, vec) {\n        for (var i = 0; i < this.structure.getNumChains(); i++) {\n            this.structure.getChain(i).setEmbeddedTargetMode(index !== i);\n            if (index !== i) {\n                this.structure.getChain(i).updateEmbeddedTarget(this.structure.getChain(i).getEffectorLocation());\n            }\n        }\n        this.structure.solveForTarget(vec);\n        this.parseStructure();\n        this.gModal = _Primatives__WEBPACK_IMPORTED_MODULE_1__[\"Primatives\"].Primitive.createModal(this.gl, this.name, this.verts, this.colors);\n    };\n    return Primitive;\n}());\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/Scene.ts?");

/***/ }),

/***/ "./src/visualisation/Shaders.ts":
/*!**************************************!*\
  !*** ./src/visualisation/Shaders.ts ***!
  \**************************************/
/*! exports provided: GridAxisShader, Primitive2DShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GridAxisShader\", function() { return GridAxisShader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Primitive2DShader\", function() { return Primitive2DShader; });\n/* harmony import */ var _Scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Scene */ \"./src/visualisation/Scene.ts\");\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/**\n * Шейдер.\n */\nvar Shader = /** @class */ (function () {\n    function Shader(gl, vertShaderSrc, fragShaderSrc) {\n        this.program = ShaderUtil.createProgramFromText(gl, vertShaderSrc, fragShaderSrc);\n        if (this.program !== null) {\n            this.gl = gl;\n            gl.useProgram(this.program);\n            this.attribLoc = ShaderUtil.getStandardAttribLocations(gl, this.program);\n            this.uniformLoc = ShaderUtil.getStandardUniformLocations(gl, this.program);\n        }\n    }\n    Shader.prototype.activate = function () {\n        this.gl.useProgram(this.program);\n        return this;\n    };\n    Shader.prototype.deactivate = function () {\n        this.gl.useProgram(null);\n        return this;\n    };\n    Shader.prototype.setPerspective = function (matData) {\n        this.gl.uniformMatrix4fv(this.uniformLoc.perspective, false, matData);\n        return this;\n    };\n    Shader.prototype.setModalMatrix = function (matData) {\n        this.gl.uniformMatrix4fv(this.uniformLoc.modalMatrix, false, matData);\n        return this;\n    };\n    Shader.prototype.setCameraMatrix = function (matData) {\n        this.gl.uniformMatrix4fv(this.uniformLoc.cameraMatrix, false, matData);\n        return this;\n    };\n    Shader.prototype.dispose = function () {\n        if (this.gl.getParameter(this.gl.CURRENT_PROGRAM) === this.program)\n            this.gl.useProgram(null);\n        this.gl.deleteProgram(this.program);\n    };\n    Shader.prototype.preRender = function () {\n    };\n    Shader.prototype.renderModal = function (modal) {\n        this.setModalMatrix(modal.transform.getViewMatrix());\n        this.gl.bindVertexArray(modal.mesh.vao);\n        if (modal.mesh.noCulling)\n            this.gl.disable(this.gl.CULL_FACE);\n        if (modal.mesh.doBlending)\n            this.gl.enable(this.gl.BLEND);\n        if (modal.mesh.indexCount)\n            this.gl.drawElements(modal.mesh.drawMode, modal.mesh.indexCount, this.gl.UNSIGNED_SHORT, 0);\n        else\n            this.gl.drawArrays(modal.mesh.drawMode, 0, modal.mesh.vertexCount);\n        this.gl.bindVertexArray(null);\n        if (modal.mesh.noCulling)\n            this.gl.enable(this.gl.CULL_FACE);\n        if (modal.mesh.doBlending)\n            this.gl.disable(this.gl.BLEND);\n        return this;\n    };\n    return Shader;\n}());\n/**\n * Вспомогательные методы для работы с шейдерами.\n */\nvar ShaderUtil = /** @class */ (function () {\n    function ShaderUtil() {\n    }\n    ShaderUtil.createShader = function (gl, src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            console.error('Error compiling shader : ' + src, gl.getShaderInfoLog(shader));\n            gl.deleteShader(shader);\n            return null;\n        }\n        return shader;\n    };\n    ShaderUtil.createProgram = function (gl, vShader, fShader, doValidate) {\n        var prog = gl.createProgram();\n        gl.attachShader(prog, vShader);\n        gl.attachShader(prog, fShader);\n        gl.bindAttribLocation(prog, _Scene__WEBPACK_IMPORTED_MODULE_0__[\"ATTR_POSITION_LOC\"], _Scene__WEBPACK_IMPORTED_MODULE_0__[\"ATTR_POSITION_NAME\"]);\n        gl.bindAttribLocation(prog, _Scene__WEBPACK_IMPORTED_MODULE_0__[\"ATTR_COLOR_LOC\"], _Scene__WEBPACK_IMPORTED_MODULE_0__[\"ATTR_COLOR_NAME\"]);\n        gl.linkProgram(prog);\n        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n            console.error('Error creating shader program.', gl.getProgramInfoLog(prog));\n            gl.deleteProgram(prog);\n            return null;\n        }\n        if (doValidate) {\n            gl.validateProgram(prog);\n            if (!gl.getProgramParameter(prog, gl.VALIDATE_STATUS)) {\n                console.error('Error validating program', gl.getProgramInfoLog(prog));\n                gl.deleteProgram(prog);\n                return null;\n            }\n        }\n        gl.detachShader(prog, vShader);\n        gl.detachShader(prog, fShader);\n        gl.deleteShader(fShader);\n        gl.deleteShader(vShader);\n        return prog;\n    };\n    ShaderUtil.createProgramFromText = function (gl, vShaderTxt, fShaderTxt) {\n        var vShader = ShaderUtil.createShader(gl, vShaderTxt, gl.VERTEX_SHADER);\n        if (!vShader)\n            return null;\n        var fShader = ShaderUtil.createShader(gl, fShaderTxt, gl.FRAGMENT_SHADER);\n        if (!fShader) {\n            gl.deleteShader(vShader);\n            return null;\n        }\n        return ShaderUtil.createProgram(gl, vShader, fShader, true);\n    };\n    ShaderUtil.getStandardAttribLocations = function (gl, program) {\n        return {\n            position: gl.getAttribLocation(program, _Scene__WEBPACK_IMPORTED_MODULE_0__[\"ATTR_POSITION_NAME\"]),\n            color: gl.getAttribLocation(program, _Scene__WEBPACK_IMPORTED_MODULE_0__[\"ATTR_COLOR_NAME\"]),\n        };\n    };\n    ShaderUtil.getStandardUniformLocations = function (gl, program) {\n        return {\n            perspective: gl.getUniformLocation(program, 'uPMatrix'),\n            modalMatrix: gl.getUniformLocation(program, 'uMVMatrix'),\n            cameraMatrix: gl.getUniformLocation(program, 'uCameraMatrix'),\n            mainTexture: gl.getUniformLocation(program, 'uMainTex'),\n        };\n    };\n    return ShaderUtil;\n}());\n/**\n * Шейдер грида.\n */\nvar GridAxisShader = /** @class */ (function (_super) {\n    __extends(GridAxisShader, _super);\n    function GridAxisShader(gl, pMatrix) {\n        var _this = this;\n        var vertSrc = '#version 300 es\\n' +\n            'in vec3 a_position;' +\n            'layout(location=4) in float a_color;' +\n            'uniform mat4 uPMatrix;' +\n            'uniform mat4 uMVMatrix;' +\n            'uniform mat4 uCameraMatrix;' +\n            'uniform vec3 uColor[4];' +\n            'out lowp vec4 color;' +\n            'void main(void){' +\n            'color = vec4(uColor[ int(a_color) ],1.0);' +\n            'gl_Position = uPMatrix * uCameraMatrix * uMVMatrix * vec4(a_position, 1.0);' +\n            '}';\n        var fragSrc = '#version 300 es\\n' +\n            'precision mediump float;' +\n            'in vec4 color;' +\n            'out vec4 finalColor;' +\n            'void main(void){ finalColor = color; }';\n        _this = _super.call(this, gl, vertSrc, fragSrc) || this;\n        _this.setPerspective(pMatrix);\n        var uColor = gl.getUniformLocation(_this.program, 'uColor');\n        gl.uniform3fv(uColor, new Float32Array([0.8, 0.8, 0.8, 1, 0, 0, 0, 1, 0, 0, 0, 1]));\n        gl.useProgram(null);\n        return _this;\n    }\n    return GridAxisShader;\n}(Shader));\n\n/**\n * Шейдер для точки и скелета.\n */\nvar Primitive2DShader = /** @class */ (function (_super) {\n    __extends(Primitive2DShader, _super);\n    function Primitive2DShader(gl, pMatrix) {\n        var _this = this;\n        var vertSrc = \"#version 300 es\\n\\t\\tin vec3 a_position;\\n\\t\\tin vec4 a_color;\\n\\n\\t\\tuniform mat4 uPMatrix;\\n\\t\\tuniform mat4 uMVMatrix;\\n\\t\\tuniform mat4 uCameraMatrix;\\n\\n\\t\\tout vec4 color;\\n\\n\\t\\tvoid main(void) {\\n\\t\\t\\tgl_PointSize = 4.0;\\n\\t\\t\\tcolor = a_color;\\n\\t\\t\\tgl_Position = uPMatrix * uCameraMatrix * uMVMatrix * vec4(a_position, 1.0); \\n\\t\\t}\";\n        var fragSrc = \"#version 300 es\\n\\t\\tprecision mediump float;\\n\\t\\tin vec4 color;\\n\\n\\t\\tout vec4 finalColor;\\n\\t\\t\\n\\t\\tvoid main(void) {\\n\\t\\t\\tfinalColor = color;\\n\\t\\t}\";\n        _this = _super.call(this, gl, vertSrc, fragSrc) || this;\n        _this.setPerspective(pMatrix);\n        gl.useProgram(null);\n        return _this;\n    }\n    return Primitive2DShader;\n}(Shader));\n\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/Shaders.ts?");

/***/ }),

/***/ "./src/visualisation/Transform.ts":
/*!****************************************!*\
  !*** ./src/visualisation/Transform.ts ***!
  \****************************************/
/*! exports provided: Transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Transform\", function() { return Transform; });\n/* harmony import */ var _utils_Vec3f__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Vec3f */ \"./src/utils/Vec3f.ts\");\n/* harmony import */ var _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Mat4f */ \"./src/utils/Mat4f.ts\");\n/* harmony import */ var _utils_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Utils */ \"./src/utils/Utils.ts\");\n\n\n\n/**\n * Положение в пространстве сцены.\n */\nvar Transform = /** @class */ (function () {\n    function Transform() {\n        this.position = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](0, 0, 0);\n        this.scale = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](1, 1, 1);\n        this.rotation = new _utils_Vec3f__WEBPACK_IMPORTED_MODULE_0__[\"Vec3f\"](0, 0, 0);\n        this.matView = new _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"]();\n        this.matNormal = new Float32Array(9);\n        this.forward = new Float32Array(4);\n        this.up = new Float32Array(4);\n        this.right = new Float32Array(4);\n    }\n    Transform.prototype.updateMatrix = function () {\n        this.matView.reset()\n            .vtranslate(this.position)\n            .rotateX(this.rotation.x * _utils_Utils__WEBPACK_IMPORTED_MODULE_2__[\"Utils\"].DEGS_TO_RADS)\n            .rotateZ(this.rotation.z * _utils_Utils__WEBPACK_IMPORTED_MODULE_2__[\"Utils\"].DEGS_TO_RADS)\n            .rotateY(this.rotation.y * _utils_Utils__WEBPACK_IMPORTED_MODULE_2__[\"Utils\"].DEGS_TO_RADS)\n            .vscale(this.scale);\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].normalMat3(this.matNormal, this.matView.raw);\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].transformVec4(this.forward, [0, 0, 1, 0], this.matView.raw);\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].transformVec4(this.up, [0, 1, 0, 0], this.matView.raw);\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].transformVec4(this.right, [1, 0, 0, 0], this.matView.raw);\n        return this.matView.raw;\n    };\n    Transform.prototype.updateDirection = function () {\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].transformVec4(this.forward, [0, 0, 1, 0], this.matView.raw);\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].transformVec4(this.up, [0, 1, 0, 0], this.matView.raw);\n        _utils_Mat4f__WEBPACK_IMPORTED_MODULE_1__[\"Mat4f\"].transformVec4(this.right, [1, 0, 0, 0], this.matView.raw);\n        return this;\n    };\n    Transform.prototype.getViewMatrix = function () {\n        return this.matView.raw;\n    };\n    Transform.prototype.reset = function () {\n        this.position.set(0, 0, 0);\n        this.scale.set(1, 1, 1);\n        this.rotation.set(0, 0, 0);\n    };\n    return Transform;\n}());\n\n\n\n//# sourceURL=webpack://MovikJS/./src/visualisation/Transform.ts?");

/***/ })

/******/ });